{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/Redis-懒删除-lazy-free-简史.md","hash":"c66b8457dbbaacf62a3346c717b51ff518c5a2d7","modified":1550554804852},{"_id":"source/_posts/Redis-scan命令原理.md","hash":"35505920bfe379da4e9d5e20f296fb16b35957a1","modified":1550503843390},{"_id":"source/_posts/Redis单机版本框架.md","hash":"26c9b582b23e189965e7297442d004cc63df0aa5","modified":1550553299645},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1550546749637},{"_id":"source/_posts/Redis有序集合指令学习.md","hash":"797cbeb5000b01a0c6c49f3eebab337fdd4f2366","modified":1550554066815},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1550546749637},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1550547754995},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1550546749637},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1550546749638},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1550546749639},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1550546749639},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1550546749639},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1550547754995},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1550546749640},{"_id":"themes/next/README.cn.md","hash":"58ffe752bc4b7f0069fcd6304bbc2d5ff7b80f89","modified":1550547754995},{"_id":"themes/next/README.md","hash":"898213e66d34a46c3cf8446bf693bd50db0d3269","modified":1550547754995},{"_id":"themes/next/_config.yml","hash":"9a2a65f0644cb31f348be626a6fbd69df6c349b6","modified":1550548388296},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1550546749641},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1550547754996},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1550547755009},{"_id":"themes/next/.git/config","hash":"510faaf0899b89e8a0a0a7ebeff0d4b0aa5ad38f","modified":1550546634328},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1550546581854},{"_id":"themes/next/.git/HEAD","hash":"66e8b5048a20ce41a8a240072e535d725d62aef4","modified":1550547755025},{"_id":"themes/next/.git/index","hash":"9948bcc96df96d60173ccca2f1958d90cc8d6057","modified":1550548339675},{"_id":"themes/next/.git/packed-refs","hash":"69237944e31c16fe545d1f47b0b1e5b1d99660da","modified":1550546749630},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1550546749637},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1550547754994},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1550547754994},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1550547754994},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1550547755009},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1550546749657},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1550547754996},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1550547754996},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1550547754996},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1550547754997},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1550547754997},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1550547754997},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1550547754997},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1550547754998},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1550547754998},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1550547754998},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1550547754999},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1550547754998},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1550547754998},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1550547754999},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1550547755000},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1550547755000},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1550547755001},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1550547755008},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1550547755008},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1550547755008},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1550546749656},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1550547755009},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1550546749656},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1550546749656},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1550546749734},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1550546749734},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1550546749734},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550546749684},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1550546581855},{"_id":"themes/next/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1550546581856},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1550546581857},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1550546581856},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1550546581855},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1550546581855},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1550546581858},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1550546581858},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1550546581859},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1550546581857},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1550546581854},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1550546581856},{"_id":"themes/next/.git/logs/HEAD","hash":"e4bf894e2f02f91200068c263a0e1daf0a665bd8","modified":1550547755025},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1550547755009},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1550546749658},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1550546749658},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1550546749658},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1550546749658},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1550546749658},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1550546749658},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1550546749659},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1550546749659},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1550546749643},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1550546749643},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1550546749643},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1550547755002},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1550547755004},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1550547755002},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1550547755003},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1550547755004},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1550546749645},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1550547755004},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1550547755005},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1550547755005},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1550546749646},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1550546749647},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1550546749647},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1550546749648},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1550546749649},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1550547755006},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1550546749653},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1550546749653},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1550546749653},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1550546749653},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1550547755008},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1550546749654},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1550546749654},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1550546749684},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1550546749685},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1550546749685},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1550547755018},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1550546749685},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1550546749686},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1550546749686},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1550546749686},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1550546749687},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1550546749687},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1550546749688},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1550547755018},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1550547755018},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1550546749688},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1550547755018},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1550546749688},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1550546749689},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1550546749690},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1550546749689},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550546749649},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550546749649},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550546749683},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550546749684},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550546749677},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550546749677},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550546749678},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1550546749646},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1550546749646},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1550546749647},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1550546749647},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1550546749647},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1550546749648},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1550546749648},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1550547755005},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1550546749648},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1550546749649},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1550546749649},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1550547755006},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1550546749649},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1550546749650},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1550546749650},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1550546749650},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1550546749650},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1550546749650},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1550547755006},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1550546749651},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1550547755007},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1550546749651},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1550546749651},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1550546749651},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1550546749652},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1550546749652},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1550546749652},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1550546749652},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1550547755007},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1550546749652},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1550547755007},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1550546749653},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1550547755007},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1550546749653},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1550546749655},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1550546749655},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1550546749655},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1550546749655},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1550547755017},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1550547755017},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1550547755017},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1550547755017},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1550547755015},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1550546749677},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1550546749678},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1550546749676},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1550546749692},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1550546749692},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1550547755018},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1550546749692},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1550546749693},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1550547755019},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1550546749693},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1550547755019},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1550546749694},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1550547755020},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1550546749694},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1550547755020},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1550546749702},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1550546749699},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1550546749708},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1550546749708},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1550546749708},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1550546749708},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1550546749703},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1550546749709},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1550546749703},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1550546749709},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1550546749709},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1550546749709},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1550546749710},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1550546749721},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1550546749722},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1550546749722},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1550546749722},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1550546749723},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1550546749723},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1550546749723},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1550546749723},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1550546749724},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1550546749723},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1550546749723},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1550546749724},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1550546749724},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1550546749724},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1550546749724},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1550546749725},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1550546749725},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1550546749725},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1550546749725},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1550546749725},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1550546749725},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1550546749726},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1550547755021},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1550547755021},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1550546749726},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1550547755021},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1550546749726},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1550546749731},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1550546749731},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1550546749733},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1550546749733},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1550546749733},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1550546749722},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1550546749632},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1550546749654},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1550546749654},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1550546749674},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1550546749674},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1550547755015},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1550546749675},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1550546749675},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1550547755015},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1550547755010},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1550547755010},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1550546749675},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1550546749659},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1550546749660},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1550546749660},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1550547755011},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1550546749670},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1550547755016},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1550546749678},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1550546749678},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1550546749678},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1550546749679},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1550546749679},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1550547755016},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1550546749679},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1550546749680},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1550546749680},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"02fb8fa6b6c252b6bed469539cd057716606a787","modified":1550547755016},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1550546749681},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1550546749681},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1550546749682},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1550546749682},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1550546749682},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1550546749682},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1550547755016},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1550546749683},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1550547755019},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1550546749697},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1550546749699},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1550546749708},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1550546749709},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1550546749704},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1550546749704},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1550546749705},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1550546749705},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1550546749705},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1550546749705},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1550546749698},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1550546749707},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1550546749707},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1550546749707},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1550546749710},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1550546749710},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1550546749711},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1550546749730},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1550546749730},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1550546749698},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1550546749720},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1550546749721},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1550546749732},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"a8fbb8c375de8902725447a0b6fef819860b1db2","modified":1550546749632},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1550547755010},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1550546749661},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1550546749660},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1550546749660},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1550546749661},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1550546749661},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1550546749661},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1550547755010},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1550547755013},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1550546749662},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1550546749668},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1550547755013},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1550546749669},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1550546749669},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1550546749669},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1550547755013},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1550546749670},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1550547755013},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1550546749670},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1550547755011},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1550546749662},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1550546749662},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1550546749662},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1550546749663},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1550547755011},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1550546749663},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1550546749663},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1550547755011},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1550546749663},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1550547755012},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1550546749664},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1550546749664},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1550547755012},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1550546749664},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1550547755012},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1550546749665},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1550546749665},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1550547755012},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1550546749671},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1550547755013},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1550546749671},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1550547755014},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1550546749672},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1550547755014},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1550546749671},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1550546749672},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1550546749672},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1550546749672},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1550546749672},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1550546749673},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1550546749673},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1550547755014},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1550546749673},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1550546749673},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1550546749673},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1550546749673},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1550547755014},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1550547755015},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1550546749680},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1550546749680},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1550546749681},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1550546749696},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1550546749697},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1550546749696},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1550546749696},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1550547755020},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1550546749705},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1550546749706},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1550546749706},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1550546749706},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1550546749706},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1550546749706},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1550546749713},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1550546749720},{"_id":"themes/next/.git/objects/pack/pack-13d3290b0a8eb9f96d0dc2f0c5a41d909767d903.idx","hash":"2b30388a8c5c0c181a2818b330b9b6b2e8c01ac4","modified":1550546749270},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1550546749702},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1550546749714},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1550546749730},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1550546749718},{"_id":"themes/next/.git/objects/pack/pack-13d3290b0a8eb9f96d0dc2f0c5a41d909767d903.pack","hash":"c9801325247a531b0818f555008af87249b5b3f1","modified":1550546749263},{"_id":"public/archives/index.html","hash":"ffc5322a270607725e0e1c243b691c0a01326d39","modified":1550554813604},{"_id":"public/archives/2018/index.html","hash":"6b52613372ea98df447a02782cddc9b606424fc5","modified":1550554813604},{"_id":"public/archives/2018/06/index.html","hash":"a77a5f3b4ad52d7b8077b124486164c324e66b05","modified":1550554813604},{"_id":"public/archives/2018/07/index.html","hash":"1253b7e07ab34cdf94ff488c14f52c4b7dcaad26","modified":1550554813604},{"_id":"public/2018/07/11/Redis有序集合指令学习/index.html","hash":"b920f6634023094369b5d358140c1821359c59c4","modified":1550554813604},{"_id":"public/2018/06/22/Redis-scan命令原理/index.html","hash":"f3c6cc5d8a0d0885ab2255e0ffda6f941adc28a7","modified":1550554813604},{"_id":"public/2018/06/07/Redis单机版本框架/index.html","hash":"6fa60ab78fb28bfad6546703a0b9c5e2eb62afcd","modified":1550554813604},{"_id":"public/index.html","hash":"3f81370f85b20302a36e8ade2fdf3e7f927be6af","modified":1550554813604},{"_id":"public/archives/2018/12/index.html","hash":"78c2780e8828cf5e3e6ae7b1ab43f9606b82b7b2","modified":1550554813691},{"_id":"public/2018/12/15/Redis-懒删除-lazy-free-简史/index.html","hash":"77cfe2eb9e3d2f6663712f3d3dd0626914c95131","modified":1550554813691},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1550554813691},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1550554813691},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1550554813691},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1550554813691},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1550554813691},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1550554813691},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1550554813691},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1550554813691},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1550554813691},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1550554813691},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1550554813692},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1550554813692},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1550554813692},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1550554813692},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1550554813692},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1550554813692},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1550554813692},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1550554813692},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1550554813692},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1550554813692},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1550554813692},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1550554813692},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1550554813692},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1550554813692},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1550554813692},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1550554813692},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1550554813692},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1550554813692},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1550554813693},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1550554813693},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1550554813693},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1550554813693},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1550554813693},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1550554814124},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1550554814127},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1550554814132},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1550554814132},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1550554814133},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1550554814133},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1550554814133},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1550554814133},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1550554814133},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1550554814133},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1550554814133},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1550554814133},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1550554814134},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1550554814134},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1550554814134},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1550554814134},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1550554814134},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1550554814134},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1550554814134},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1550554814134},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1550554814134},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1550554814134},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1550554814134},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1550554814134},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1550554814134},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1550554814134},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1550554814134},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1550554814134},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1550554814134},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1550554814134},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1550554814134},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1550554814135},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1550554814135},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1550554814135},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1550554814135},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1550554814135},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1550554814135},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1550554814135},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1550554814135},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1550554814135},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1550554814135},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1550554814135},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1550554814135},{"_id":"public/css/main.css","hash":"2b65c86f69482bab431b7e79f4a3912aa26ab3f8","modified":1550554814135},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1550554814135},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1550554814135},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1550554814136},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1550554814138},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1550554814138},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1550554814139},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1550554814139},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1550554814139},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1550554814139},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1550554814139},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1550554814139},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1550554814143},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1550554814144},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1550554814147},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1550554814148},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1550554814156},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1550554814156},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1550554814157},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1550554814157},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1550554814157},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1550554814157},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1550554814157},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1550554814159},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1550554814159},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1550554814160},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1550554814161},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1550554814162},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1550554814165},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1550554814165},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1550554814170},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1550554814179},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1550554814182}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Redis scan命令原理","date":"2018-06-22T14:57:39.000Z","_content":"\n## scan类型命令\n```\nSCAN cursor [MATCH pattern] [COUNT count]\n\nSSCAN KEY cursor [MATCH pattern] [COUNT count]\n\nHSCAN  KEY cursor [MATCH pattern] [COUNT count]\n\nZSCAN KEY cursor [MATCH pattern] [COUNT count]\n```\nscan:迭代当前库\n\nsscan:迭代一个 set 类型\n\nhscan:迭代一个hash类型,并返回相应的值\n\nzscan:迭代一个sorted set，并且返回相应的分数\n\nredis是单进程单线程模型,keys和smembers这种命令可能会阻塞服务器,所以出现了scan系列的命令,通过返回一个游标，可以增量式迭代.\n\n## scan类型命令的实现\nscan,sscan,hscan,zsan分别有自己的命令入口,入口中会进行参数检测和游标赋值,然后进入统一的入口函数:scanGenericCommand,以hscan命令为例:\n\n![hscan](/img/scan1.png)\n\nscanGenericCommand主要分四步:\n\n* 解析count和match参数.如果没有指定count,默认返回10条数据\n* 开始迭代集合,如果是key保存为ziplist或者intset,则一次性返回所有数据,没有游标(游标值直接返回0).由于redis设计只有数据量比较小的时候才会保存为ziplist或者intset,所以此处不会影响性能.\n游标在保存为hash的时候发挥作用,具体入口函数为dictScan,下文详细描述。\n* 根据match参数过滤返回值,并且如果这个键已经过期也会直接过滤掉(redis中键过期之后并不会立即删除)\n* 返回结果到客户端,是一个数组,第一个值是游标,第二个值是具体的键值对\n\n## dictScan中游标的实现\n当迭代一个哈希表时,存在三种情况：\n\n* 从迭代开始到结束,哈希表没有进行rehash\n* 从迭代开始到结束,哈希表进行了rehash,但是每次迭代时,哈希表要么没开始rehash,要么已经结束了rehash\n* 从迭代开始到结束,某次或某几次迭代时哈希表正在进行rehash\nredis中进行rehash时会存在两个哈希表，ht[0]与ht[1],并且是渐进式rehash(即不会一次性全部rehash);新的键值对会存放到ht[1]中并且会逐步将ht[0]的数据转移到ht[1].全部rehash完毕后,ht[1]赋值给ht[0]然后清空ht[1].\n\n因此游标的实现需要兼顾以上三种情况,以上三种情况的游标实现要求如下:\n\n* 第一种情况比较简单,假设redis的哈希表大小为4,则第一次游标为0,读取第一个bucket的数据,然后游标返回1,下次读取第二个bucket的位置,依次遍历\n* 第二种情况比较复杂,假设redis的哈希表大小为4,如果rehash完后size变成了8.如果仍然按照上边的思路返回游标,则如下图:\n\n![scan](/img/scan2.png)\n\n\n 假设bucket0读完之后返回了游标1,当客户端再次带着游标1返回时哈希表已经进行完rehash,并且size扩大了一倍变成了8.redis按如下方法计算一个键的bucket:\n\n``` c\nhash(key)&(size-1)\n```\n即如果size是4时,hash(key)&11,如果size是8时,hash(key)&111.因此当从4扩容到8时,原先在0bucket的数据会分散到0(000)与4(100)两个bucket,bucket对应关系表如下:\n\n![scan](/img/scan3.png)\n\n从二进制来看,当size为4时,hash(key)之后取低两位即 hash(key)&11即key的bucket位置,如果size为8时,bucket位置为 hash(key)&111，即取低三位,当低两位为00时,如果第三位为0,则为000,如果第三位为1,则为100,正好是4.其他槽位的类似.所以如果此时继续按第一种方法遍历,第四个bucket取到的值全部为重复值\n\n*  第三种情况，如果返回游标1时正在进行rehash,ht[0]中的bucket 1中的部分数据可能已经rehash到 ht[1]中的bucket[1]或者bucket[5]，此时必须将ht[0]和ht[1]中的相应bucket全部遍历,否则可能会有遗漏数据\n\n所以为了兼顾以上三种情况,做到不漏数据并且尽量不重复,redis使用了一种叫做reverse binary iteration的方法.具体的游标计算代码如下:\n\n![reverse binary](/img/scan4.png)\n\n代码逻辑很简单,下面示例从4变为8和从4变为16以及从8变为4和从16变为4时,这种方法为何能够做到不重不漏\n\n![transfer](/img/scan5.png)\n\n遍历size为4时的游标状态转移为0-2-1-3.\n\n同理,size为8时的游标状态转移为0-4-2-6-1-5-3-7.\n\nsize为16时的游标状态转义为0-8-4-12-2-10-6-14-1-9-5-13-3-11-7-15\n\n![transfer](/img/scan6.png)\n\n\n可以看出，当size由小变大时,所有原来的游标都能在大的hashTable中找到相应的位置,并且顺序一致,不会重复读取并且不会遗漏\n\n例如size原来是4变为了8,且第二次遍历时rehash已经完成.此时游标为2,根据图2,我们知道size为4时的bucket2会rehash到size为8时的2和6.而size为4时的bucket0rehash到size为8时的0和4\n\n由于bucket 0 已经遍历完,也即size为8时的0,4已经遍历,正好开始从2开始继续遍历,不重复也不会遗漏\n\n\n\n继续考虑size由大变小的情况.假设size由16变为了4,分两种情况,一种是游标为0,2,1,3中的一种,此时继续读取,也不会遗漏和重复\n\n但如果游标返回的不是这四种,例如返回了10,10&11之后变为了2,所以会从2开始继续遍历.但由于size为16时的bucket2已经读取过,并且2,10,6,14都会rehash到size为4的bucket2,所以会造成重复读取\n\nsize为16时的bucket2。即有重复但不会遗漏\n\n**总结一下:redis里边rehash从小到大时，scan系列命令不会重复也不会遗漏.而从大到小时,有可能会造成重复但不会遗漏.**\n\n截止目前,情况1和情况2已经比较完美的处理了。情况3看看如何处理\n\n情况3需要从ht[0]和ht[1]中都取出数据,主要的难点在于如何在size大的哈希表中找到应该取哪些bucket.redis代码如下:\n\n![transfer](/img/scan7.png)\n\n判断条件为:\n\n```\nv&(m0^m1)\n```\nsize 4的m0为00000011,size8的m1为00000111,二者异或之后取值为00000100,即取二者mask高位的值,然后&v,看游标是否在高位还有值\n\n下一个游标的取值方法为 \n```\nv = (  ((v | m0) +1)& ~m0) | ( v & m0)\n```\n右半部分 取v的低位,左半部分取v的高位。  （v&m0)取出v的低位 例如size = 4时为 v&00000011\n\n左半部分 （v|m0) + 1即将v的低位都置为1,然后+1之后会进位到v的高位,再次 & ~m0之后即取出了v的高位\n\n整体来看每次将游标v的高位加1.下边举例来看:\n\n假设游标返回了2,并且正在进行rehash,此时size由4变成了8 .则m0 = 00000011 v = 00000010\n\n根据公式计算出的下一个游标为 ( (( 00000010|00000011) +1 ) & (11111100) )| (00000010 & 00000011) = (00000100)&(11111100)|(00000010) = (00000110) 正好是6\n\n判断条件为 (00000010) & (00000011 ^ 00000111) = (00000010) & (00000100) = (00000000) 为0，结束循环","source":"_posts/Redis-scan命令原理.md","raw":"---\ntitle: Redis scan命令原理\ndate: 2018-06-22 22:57:39\ntags:\n---\n\n## scan类型命令\n```\nSCAN cursor [MATCH pattern] [COUNT count]\n\nSSCAN KEY cursor [MATCH pattern] [COUNT count]\n\nHSCAN  KEY cursor [MATCH pattern] [COUNT count]\n\nZSCAN KEY cursor [MATCH pattern] [COUNT count]\n```\nscan:迭代当前库\n\nsscan:迭代一个 set 类型\n\nhscan:迭代一个hash类型,并返回相应的值\n\nzscan:迭代一个sorted set，并且返回相应的分数\n\nredis是单进程单线程模型,keys和smembers这种命令可能会阻塞服务器,所以出现了scan系列的命令,通过返回一个游标，可以增量式迭代.\n\n## scan类型命令的实现\nscan,sscan,hscan,zsan分别有自己的命令入口,入口中会进行参数检测和游标赋值,然后进入统一的入口函数:scanGenericCommand,以hscan命令为例:\n\n![hscan](/img/scan1.png)\n\nscanGenericCommand主要分四步:\n\n* 解析count和match参数.如果没有指定count,默认返回10条数据\n* 开始迭代集合,如果是key保存为ziplist或者intset,则一次性返回所有数据,没有游标(游标值直接返回0).由于redis设计只有数据量比较小的时候才会保存为ziplist或者intset,所以此处不会影响性能.\n游标在保存为hash的时候发挥作用,具体入口函数为dictScan,下文详细描述。\n* 根据match参数过滤返回值,并且如果这个键已经过期也会直接过滤掉(redis中键过期之后并不会立即删除)\n* 返回结果到客户端,是一个数组,第一个值是游标,第二个值是具体的键值对\n\n## dictScan中游标的实现\n当迭代一个哈希表时,存在三种情况：\n\n* 从迭代开始到结束,哈希表没有进行rehash\n* 从迭代开始到结束,哈希表进行了rehash,但是每次迭代时,哈希表要么没开始rehash,要么已经结束了rehash\n* 从迭代开始到结束,某次或某几次迭代时哈希表正在进行rehash\nredis中进行rehash时会存在两个哈希表，ht[0]与ht[1],并且是渐进式rehash(即不会一次性全部rehash);新的键值对会存放到ht[1]中并且会逐步将ht[0]的数据转移到ht[1].全部rehash完毕后,ht[1]赋值给ht[0]然后清空ht[1].\n\n因此游标的实现需要兼顾以上三种情况,以上三种情况的游标实现要求如下:\n\n* 第一种情况比较简单,假设redis的哈希表大小为4,则第一次游标为0,读取第一个bucket的数据,然后游标返回1,下次读取第二个bucket的位置,依次遍历\n* 第二种情况比较复杂,假设redis的哈希表大小为4,如果rehash完后size变成了8.如果仍然按照上边的思路返回游标,则如下图:\n\n![scan](/img/scan2.png)\n\n\n 假设bucket0读完之后返回了游标1,当客户端再次带着游标1返回时哈希表已经进行完rehash,并且size扩大了一倍变成了8.redis按如下方法计算一个键的bucket:\n\n``` c\nhash(key)&(size-1)\n```\n即如果size是4时,hash(key)&11,如果size是8时,hash(key)&111.因此当从4扩容到8时,原先在0bucket的数据会分散到0(000)与4(100)两个bucket,bucket对应关系表如下:\n\n![scan](/img/scan3.png)\n\n从二进制来看,当size为4时,hash(key)之后取低两位即 hash(key)&11即key的bucket位置,如果size为8时,bucket位置为 hash(key)&111，即取低三位,当低两位为00时,如果第三位为0,则为000,如果第三位为1,则为100,正好是4.其他槽位的类似.所以如果此时继续按第一种方法遍历,第四个bucket取到的值全部为重复值\n\n*  第三种情况，如果返回游标1时正在进行rehash,ht[0]中的bucket 1中的部分数据可能已经rehash到 ht[1]中的bucket[1]或者bucket[5]，此时必须将ht[0]和ht[1]中的相应bucket全部遍历,否则可能会有遗漏数据\n\n所以为了兼顾以上三种情况,做到不漏数据并且尽量不重复,redis使用了一种叫做reverse binary iteration的方法.具体的游标计算代码如下:\n\n![reverse binary](/img/scan4.png)\n\n代码逻辑很简单,下面示例从4变为8和从4变为16以及从8变为4和从16变为4时,这种方法为何能够做到不重不漏\n\n![transfer](/img/scan5.png)\n\n遍历size为4时的游标状态转移为0-2-1-3.\n\n同理,size为8时的游标状态转移为0-4-2-6-1-5-3-7.\n\nsize为16时的游标状态转义为0-8-4-12-2-10-6-14-1-9-5-13-3-11-7-15\n\n![transfer](/img/scan6.png)\n\n\n可以看出，当size由小变大时,所有原来的游标都能在大的hashTable中找到相应的位置,并且顺序一致,不会重复读取并且不会遗漏\n\n例如size原来是4变为了8,且第二次遍历时rehash已经完成.此时游标为2,根据图2,我们知道size为4时的bucket2会rehash到size为8时的2和6.而size为4时的bucket0rehash到size为8时的0和4\n\n由于bucket 0 已经遍历完,也即size为8时的0,4已经遍历,正好开始从2开始继续遍历,不重复也不会遗漏\n\n\n\n继续考虑size由大变小的情况.假设size由16变为了4,分两种情况,一种是游标为0,2,1,3中的一种,此时继续读取,也不会遗漏和重复\n\n但如果游标返回的不是这四种,例如返回了10,10&11之后变为了2,所以会从2开始继续遍历.但由于size为16时的bucket2已经读取过,并且2,10,6,14都会rehash到size为4的bucket2,所以会造成重复读取\n\nsize为16时的bucket2。即有重复但不会遗漏\n\n**总结一下:redis里边rehash从小到大时，scan系列命令不会重复也不会遗漏.而从大到小时,有可能会造成重复但不会遗漏.**\n\n截止目前,情况1和情况2已经比较完美的处理了。情况3看看如何处理\n\n情况3需要从ht[0]和ht[1]中都取出数据,主要的难点在于如何在size大的哈希表中找到应该取哪些bucket.redis代码如下:\n\n![transfer](/img/scan7.png)\n\n判断条件为:\n\n```\nv&(m0^m1)\n```\nsize 4的m0为00000011,size8的m1为00000111,二者异或之后取值为00000100,即取二者mask高位的值,然后&v,看游标是否在高位还有值\n\n下一个游标的取值方法为 \n```\nv = (  ((v | m0) +1)& ~m0) | ( v & m0)\n```\n右半部分 取v的低位,左半部分取v的高位。  （v&m0)取出v的低位 例如size = 4时为 v&00000011\n\n左半部分 （v|m0) + 1即将v的低位都置为1,然后+1之后会进位到v的高位,再次 & ~m0之后即取出了v的高位\n\n整体来看每次将游标v的高位加1.下边举例来看:\n\n假设游标返回了2,并且正在进行rehash,此时size由4变成了8 .则m0 = 00000011 v = 00000010\n\n根据公式计算出的下一个游标为 ( (( 00000010|00000011) +1 ) & (11111100) )| (00000010 & 00000011) = (00000100)&(11111100)|(00000010) = (00000110) 正好是6\n\n判断条件为 (00000010) & (00000011 ^ 00000111) = (00000010) & (00000100) = (00000000) 为0，结束循环","slug":"Redis-scan命令原理","published":1,"updated":"2019-02-18T15:30:43.390Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsbcaud20000zlfy3aep1ucb","content":"<h2 id=\"scan类型命令\"><a href=\"#scan类型命令\" class=\"headerlink\" title=\"scan类型命令\"></a>scan类型命令</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SCAN cursor [MATCH pattern] [COUNT count]</span><br><span class=\"line\"></span><br><span class=\"line\">SSCAN KEY cursor [MATCH pattern] [COUNT count]</span><br><span class=\"line\"></span><br><span class=\"line\">HSCAN  KEY cursor [MATCH pattern] [COUNT count]</span><br><span class=\"line\"></span><br><span class=\"line\">ZSCAN KEY cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure>\n<p>scan:迭代当前库</p>\n<p>sscan:迭代一个 set 类型</p>\n<p>hscan:迭代一个hash类型,并返回相应的值</p>\n<p>zscan:迭代一个sorted set，并且返回相应的分数</p>\n<p>redis是单进程单线程模型,keys和smembers这种命令可能会阻塞服务器,所以出现了scan系列的命令,通过返回一个游标，可以增量式迭代.</p>\n<h2 id=\"scan类型命令的实现\"><a href=\"#scan类型命令的实现\" class=\"headerlink\" title=\"scan类型命令的实现\"></a>scan类型命令的实现</h2><p>scan,sscan,hscan,zsan分别有自己的命令入口,入口中会进行参数检测和游标赋值,然后进入统一的入口函数:scanGenericCommand,以hscan命令为例:</p>\n<p><img src=\"/img/scan1.png\" alt=\"hscan\"></p>\n<p>scanGenericCommand主要分四步:</p>\n<ul>\n<li>解析count和match参数.如果没有指定count,默认返回10条数据</li>\n<li>开始迭代集合,如果是key保存为ziplist或者intset,则一次性返回所有数据,没有游标(游标值直接返回0).由于redis设计只有数据量比较小的时候才会保存为ziplist或者intset,所以此处不会影响性能.<br>游标在保存为hash的时候发挥作用,具体入口函数为dictScan,下文详细描述。</li>\n<li>根据match参数过滤返回值,并且如果这个键已经过期也会直接过滤掉(redis中键过期之后并不会立即删除)</li>\n<li>返回结果到客户端,是一个数组,第一个值是游标,第二个值是具体的键值对</li>\n</ul>\n<h2 id=\"dictScan中游标的实现\"><a href=\"#dictScan中游标的实现\" class=\"headerlink\" title=\"dictScan中游标的实现\"></a>dictScan中游标的实现</h2><p>当迭代一个哈希表时,存在三种情况：</p>\n<ul>\n<li>从迭代开始到结束,哈希表没有进行rehash</li>\n<li>从迭代开始到结束,哈希表进行了rehash,但是每次迭代时,哈希表要么没开始rehash,要么已经结束了rehash</li>\n<li>从迭代开始到结束,某次或某几次迭代时哈希表正在进行rehash<br>redis中进行rehash时会存在两个哈希表，ht[0]与ht[1],并且是渐进式rehash(即不会一次性全部rehash);新的键值对会存放到ht[1]中并且会逐步将ht[0]的数据转移到ht[1].全部rehash完毕后,ht[1]赋值给ht[0]然后清空ht[1].</li>\n</ul>\n<p>因此游标的实现需要兼顾以上三种情况,以上三种情况的游标实现要求如下:</p>\n<ul>\n<li>第一种情况比较简单,假设redis的哈希表大小为4,则第一次游标为0,读取第一个bucket的数据,然后游标返回1,下次读取第二个bucket的位置,依次遍历</li>\n<li>第二种情况比较复杂,假设redis的哈希表大小为4,如果rehash完后size变成了8.如果仍然按照上边的思路返回游标,则如下图:</li>\n</ul>\n<p><img src=\"/img/scan2.png\" alt=\"scan\"></p>\n<p> 假设bucket0读完之后返回了游标1,当客户端再次带着游标1返回时哈希表已经进行完rehash,并且size扩大了一倍变成了8.redis按如下方法计算一个键的bucket:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hash(key)&amp;(size<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure>\n<p>即如果size是4时,hash(key)&amp;11,如果size是8时,hash(key)&amp;111.因此当从4扩容到8时,原先在0bucket的数据会分散到0(000)与4(100)两个bucket,bucket对应关系表如下:</p>\n<p><img src=\"/img/scan3.png\" alt=\"scan\"></p>\n<p>从二进制来看,当size为4时,hash(key)之后取低两位即 hash(key)&amp;11即key的bucket位置,如果size为8时,bucket位置为 hash(key)&amp;111，即取低三位,当低两位为00时,如果第三位为0,则为000,如果第三位为1,则为100,正好是4.其他槽位的类似.所以如果此时继续按第一种方法遍历,第四个bucket取到的值全部为重复值</p>\n<ul>\n<li>第三种情况，如果返回游标1时正在进行rehash,ht[0]中的bucket 1中的部分数据可能已经rehash到 ht[1]中的bucket[1]或者bucket[5]，此时必须将ht[0]和ht[1]中的相应bucket全部遍历,否则可能会有遗漏数据</li>\n</ul>\n<p>所以为了兼顾以上三种情况,做到不漏数据并且尽量不重复,redis使用了一种叫做reverse binary iteration的方法.具体的游标计算代码如下:</p>\n<p><img src=\"/img/scan4.png\" alt=\"reverse binary\"></p>\n<p>代码逻辑很简单,下面示例从4变为8和从4变为16以及从8变为4和从16变为4时,这种方法为何能够做到不重不漏</p>\n<p><img src=\"/img/scan5.png\" alt=\"transfer\"></p>\n<p>遍历size为4时的游标状态转移为0-2-1-3.</p>\n<p>同理,size为8时的游标状态转移为0-4-2-6-1-5-3-7.</p>\n<p>size为16时的游标状态转义为0-8-4-12-2-10-6-14-1-9-5-13-3-11-7-15</p>\n<p><img src=\"/img/scan6.png\" alt=\"transfer\"></p>\n<p>可以看出，当size由小变大时,所有原来的游标都能在大的hashTable中找到相应的位置,并且顺序一致,不会重复读取并且不会遗漏</p>\n<p>例如size原来是4变为了8,且第二次遍历时rehash已经完成.此时游标为2,根据图2,我们知道size为4时的bucket2会rehash到size为8时的2和6.而size为4时的bucket0rehash到size为8时的0和4</p>\n<p>由于bucket 0 已经遍历完,也即size为8时的0,4已经遍历,正好开始从2开始继续遍历,不重复也不会遗漏</p>\n<p>继续考虑size由大变小的情况.假设size由16变为了4,分两种情况,一种是游标为0,2,1,3中的一种,此时继续读取,也不会遗漏和重复</p>\n<p>但如果游标返回的不是这四种,例如返回了10,10&amp;11之后变为了2,所以会从2开始继续遍历.但由于size为16时的bucket2已经读取过,并且2,10,6,14都会rehash到size为4的bucket2,所以会造成重复读取</p>\n<p>size为16时的bucket2。即有重复但不会遗漏</p>\n<p><strong>总结一下:redis里边rehash从小到大时，scan系列命令不会重复也不会遗漏.而从大到小时,有可能会造成重复但不会遗漏.</strong></p>\n<p>截止目前,情况1和情况2已经比较完美的处理了。情况3看看如何处理</p>\n<p>情况3需要从ht[0]和ht[1]中都取出数据,主要的难点在于如何在size大的哈希表中找到应该取哪些bucket.redis代码如下:</p>\n<p><img src=\"/img/scan7.png\" alt=\"transfer\"></p>\n<p>判断条件为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v&amp;(m0^m1)</span><br></pre></td></tr></table></figure>\n<p>size 4的m0为00000011,size8的m1为00000111,二者异或之后取值为00000100,即取二者mask高位的值,然后&amp;v,看游标是否在高位还有值</p>\n<p>下一个游标的取值方法为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v = (  ((v | m0) +1)&amp; ~m0) | ( v &amp; m0)</span><br></pre></td></tr></table></figure></p>\n<p>右半部分 取v的低位,左半部分取v的高位。  （v&amp;m0)取出v的低位 例如size = 4时为 v&amp;00000011</p>\n<p>左半部分 （v|m0) + 1即将v的低位都置为1,然后+1之后会进位到v的高位,再次 &amp; ~m0之后即取出了v的高位</p>\n<p>整体来看每次将游标v的高位加1.下边举例来看:</p>\n<p>假设游标返回了2,并且正在进行rehash,此时size由4变成了8 .则m0 = 00000011 v = 00000010</p>\n<p>根据公式计算出的下一个游标为 ( (( 00000010|00000011) +1 ) &amp; (11111100) )| (00000010 &amp; 00000011) = (00000100)&amp;(11111100)|(00000010) = (00000110) 正好是6</p>\n<p>判断条件为 (00000010) &amp; (00000011 ^ 00000111) = (00000010) &amp; (00000100) = (00000000) 为0，结束循环</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"scan类型命令\"><a href=\"#scan类型命令\" class=\"headerlink\" title=\"scan类型命令\"></a>scan类型命令</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SCAN cursor [MATCH pattern] [COUNT count]</span><br><span class=\"line\"></span><br><span class=\"line\">SSCAN KEY cursor [MATCH pattern] [COUNT count]</span><br><span class=\"line\"></span><br><span class=\"line\">HSCAN  KEY cursor [MATCH pattern] [COUNT count]</span><br><span class=\"line\"></span><br><span class=\"line\">ZSCAN KEY cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure>\n<p>scan:迭代当前库</p>\n<p>sscan:迭代一个 set 类型</p>\n<p>hscan:迭代一个hash类型,并返回相应的值</p>\n<p>zscan:迭代一个sorted set，并且返回相应的分数</p>\n<p>redis是单进程单线程模型,keys和smembers这种命令可能会阻塞服务器,所以出现了scan系列的命令,通过返回一个游标，可以增量式迭代.</p>\n<h2 id=\"scan类型命令的实现\"><a href=\"#scan类型命令的实现\" class=\"headerlink\" title=\"scan类型命令的实现\"></a>scan类型命令的实现</h2><p>scan,sscan,hscan,zsan分别有自己的命令入口,入口中会进行参数检测和游标赋值,然后进入统一的入口函数:scanGenericCommand,以hscan命令为例:</p>\n<p><img src=\"/img/scan1.png\" alt=\"hscan\"></p>\n<p>scanGenericCommand主要分四步:</p>\n<ul>\n<li>解析count和match参数.如果没有指定count,默认返回10条数据</li>\n<li>开始迭代集合,如果是key保存为ziplist或者intset,则一次性返回所有数据,没有游标(游标值直接返回0).由于redis设计只有数据量比较小的时候才会保存为ziplist或者intset,所以此处不会影响性能.<br>游标在保存为hash的时候发挥作用,具体入口函数为dictScan,下文详细描述。</li>\n<li>根据match参数过滤返回值,并且如果这个键已经过期也会直接过滤掉(redis中键过期之后并不会立即删除)</li>\n<li>返回结果到客户端,是一个数组,第一个值是游标,第二个值是具体的键值对</li>\n</ul>\n<h2 id=\"dictScan中游标的实现\"><a href=\"#dictScan中游标的实现\" class=\"headerlink\" title=\"dictScan中游标的实现\"></a>dictScan中游标的实现</h2><p>当迭代一个哈希表时,存在三种情况：</p>\n<ul>\n<li>从迭代开始到结束,哈希表没有进行rehash</li>\n<li>从迭代开始到结束,哈希表进行了rehash,但是每次迭代时,哈希表要么没开始rehash,要么已经结束了rehash</li>\n<li>从迭代开始到结束,某次或某几次迭代时哈希表正在进行rehash<br>redis中进行rehash时会存在两个哈希表，ht[0]与ht[1],并且是渐进式rehash(即不会一次性全部rehash);新的键值对会存放到ht[1]中并且会逐步将ht[0]的数据转移到ht[1].全部rehash完毕后,ht[1]赋值给ht[0]然后清空ht[1].</li>\n</ul>\n<p>因此游标的实现需要兼顾以上三种情况,以上三种情况的游标实现要求如下:</p>\n<ul>\n<li>第一种情况比较简单,假设redis的哈希表大小为4,则第一次游标为0,读取第一个bucket的数据,然后游标返回1,下次读取第二个bucket的位置,依次遍历</li>\n<li>第二种情况比较复杂,假设redis的哈希表大小为4,如果rehash完后size变成了8.如果仍然按照上边的思路返回游标,则如下图:</li>\n</ul>\n<p><img src=\"/img/scan2.png\" alt=\"scan\"></p>\n<p> 假设bucket0读完之后返回了游标1,当客户端再次带着游标1返回时哈希表已经进行完rehash,并且size扩大了一倍变成了8.redis按如下方法计算一个键的bucket:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hash(key)&amp;(size<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure>\n<p>即如果size是4时,hash(key)&amp;11,如果size是8时,hash(key)&amp;111.因此当从4扩容到8时,原先在0bucket的数据会分散到0(000)与4(100)两个bucket,bucket对应关系表如下:</p>\n<p><img src=\"/img/scan3.png\" alt=\"scan\"></p>\n<p>从二进制来看,当size为4时,hash(key)之后取低两位即 hash(key)&amp;11即key的bucket位置,如果size为8时,bucket位置为 hash(key)&amp;111，即取低三位,当低两位为00时,如果第三位为0,则为000,如果第三位为1,则为100,正好是4.其他槽位的类似.所以如果此时继续按第一种方法遍历,第四个bucket取到的值全部为重复值</p>\n<ul>\n<li>第三种情况，如果返回游标1时正在进行rehash,ht[0]中的bucket 1中的部分数据可能已经rehash到 ht[1]中的bucket[1]或者bucket[5]，此时必须将ht[0]和ht[1]中的相应bucket全部遍历,否则可能会有遗漏数据</li>\n</ul>\n<p>所以为了兼顾以上三种情况,做到不漏数据并且尽量不重复,redis使用了一种叫做reverse binary iteration的方法.具体的游标计算代码如下:</p>\n<p><img src=\"/img/scan4.png\" alt=\"reverse binary\"></p>\n<p>代码逻辑很简单,下面示例从4变为8和从4变为16以及从8变为4和从16变为4时,这种方法为何能够做到不重不漏</p>\n<p><img src=\"/img/scan5.png\" alt=\"transfer\"></p>\n<p>遍历size为4时的游标状态转移为0-2-1-3.</p>\n<p>同理,size为8时的游标状态转移为0-4-2-6-1-5-3-7.</p>\n<p>size为16时的游标状态转义为0-8-4-12-2-10-6-14-1-9-5-13-3-11-7-15</p>\n<p><img src=\"/img/scan6.png\" alt=\"transfer\"></p>\n<p>可以看出，当size由小变大时,所有原来的游标都能在大的hashTable中找到相应的位置,并且顺序一致,不会重复读取并且不会遗漏</p>\n<p>例如size原来是4变为了8,且第二次遍历时rehash已经完成.此时游标为2,根据图2,我们知道size为4时的bucket2会rehash到size为8时的2和6.而size为4时的bucket0rehash到size为8时的0和4</p>\n<p>由于bucket 0 已经遍历完,也即size为8时的0,4已经遍历,正好开始从2开始继续遍历,不重复也不会遗漏</p>\n<p>继续考虑size由大变小的情况.假设size由16变为了4,分两种情况,一种是游标为0,2,1,3中的一种,此时继续读取,也不会遗漏和重复</p>\n<p>但如果游标返回的不是这四种,例如返回了10,10&amp;11之后变为了2,所以会从2开始继续遍历.但由于size为16时的bucket2已经读取过,并且2,10,6,14都会rehash到size为4的bucket2,所以会造成重复读取</p>\n<p>size为16时的bucket2。即有重复但不会遗漏</p>\n<p><strong>总结一下:redis里边rehash从小到大时，scan系列命令不会重复也不会遗漏.而从大到小时,有可能会造成重复但不会遗漏.</strong></p>\n<p>截止目前,情况1和情况2已经比较完美的处理了。情况3看看如何处理</p>\n<p>情况3需要从ht[0]和ht[1]中都取出数据,主要的难点在于如何在size大的哈希表中找到应该取哪些bucket.redis代码如下:</p>\n<p><img src=\"/img/scan7.png\" alt=\"transfer\"></p>\n<p>判断条件为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v&amp;(m0^m1)</span><br></pre></td></tr></table></figure>\n<p>size 4的m0为00000011,size8的m1为00000111,二者异或之后取值为00000100,即取二者mask高位的值,然后&amp;v,看游标是否在高位还有值</p>\n<p>下一个游标的取值方法为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v = (  ((v | m0) +1)&amp; ~m0) | ( v &amp; m0)</span><br></pre></td></tr></table></figure></p>\n<p>右半部分 取v的低位,左半部分取v的高位。  （v&amp;m0)取出v的低位 例如size = 4时为 v&amp;00000011</p>\n<p>左半部分 （v|m0) + 1即将v的低位都置为1,然后+1之后会进位到v的高位,再次 &amp; ~m0之后即取出了v的高位</p>\n<p>整体来看每次将游标v的高位加1.下边举例来看:</p>\n<p>假设游标返回了2,并且正在进行rehash,此时size由4变成了8 .则m0 = 00000011 v = 00000010</p>\n<p>根据公式计算出的下一个游标为 ( (( 00000010|00000011) +1 ) &amp; (11111100) )| (00000010 &amp; 00000011) = (00000100)&amp;(11111100)|(00000010) = (00000110) 正好是6</p>\n<p>判断条件为 (00000010) &amp; (00000011 ^ 00000111) = (00000010) &amp; (00000100) = (00000000) 为0，结束循环</p>\n"},{"title":"Redis单机版本框架","date":"2018-06-07T05:07:29.000Z","_content":"## Redis主流程伪代码\n```\ndef main():\n init_server()\n \n while server_is_not_shutdown():\n       time = aeSearchNearestTimer()\n       beforeSleep()\n       aeApiPoll(time)\n       processFileEvents()\n       processTimeEvents()\n \n clean_server()\n ```\n\n## Redis main函数调用流程图及关键节点\n![call](/img/rs1.jpg)\n\n## 一条简单的set命令的执行流程\n\n![flow](/img/rs2.jpg)\n\n## serverCron函数的功能\n\n![flow](/img/rs3.jpg)\n\n## Q&A\n1.bgsave执行时再次执行bgsave如何处理？\n\n直接返回,返回信息会通知正在执行.\n\n如果在aof rewrite时执行bgsave,会直接返回不能执行.\n\n看代码此处应该有bgsave schedule命令,如果此时在执行aof rewrite,则会在aof结束后在serverCron中执行。\n\n代码如下 \n\n![flow](/img/rs4.png)\n\n2.aof rewrite正在执行时再次发送bgrewriteaof会如何处理?\n\n直接返回,返回信息通知正在执行\n\n如果此时在执行rdbsave,则会在serverCron中在rdbsave结束之后执行aof rewrite.\n\n代码如下:\n\n![flow](/img/rs5.png)\n\n3.bgsave时如果master还在执行写入,由于linux COW机制,此时会给子进程拷贝一份数据,导致双倍内存。\n\n 待在测试环境验证是否会出现\n\n4.client端发送的命令能否在server端保证顺序?\n\n5.为什么redis本身支持分布式生产环境还在使用codis？","source":"_posts/Redis单机版本框架.md","raw":"---\ntitle: Redis单机版本框架\ndate: 2018-06-07 13:07:29\ntags:\n---\n## Redis主流程伪代码\n```\ndef main():\n init_server()\n \n while server_is_not_shutdown():\n       time = aeSearchNearestTimer()\n       beforeSleep()\n       aeApiPoll(time)\n       processFileEvents()\n       processTimeEvents()\n \n clean_server()\n ```\n\n## Redis main函数调用流程图及关键节点\n![call](/img/rs1.jpg)\n\n## 一条简单的set命令的执行流程\n\n![flow](/img/rs2.jpg)\n\n## serverCron函数的功能\n\n![flow](/img/rs3.jpg)\n\n## Q&A\n1.bgsave执行时再次执行bgsave如何处理？\n\n直接返回,返回信息会通知正在执行.\n\n如果在aof rewrite时执行bgsave,会直接返回不能执行.\n\n看代码此处应该有bgsave schedule命令,如果此时在执行aof rewrite,则会在aof结束后在serverCron中执行。\n\n代码如下 \n\n![flow](/img/rs4.png)\n\n2.aof rewrite正在执行时再次发送bgrewriteaof会如何处理?\n\n直接返回,返回信息通知正在执行\n\n如果此时在执行rdbsave,则会在serverCron中在rdbsave结束之后执行aof rewrite.\n\n代码如下:\n\n![flow](/img/rs5.png)\n\n3.bgsave时如果master还在执行写入,由于linux COW机制,此时会给子进程拷贝一份数据,导致双倍内存。\n\n 待在测试环境验证是否会出现\n\n4.client端发送的命令能否在server端保证顺序?\n\n5.为什么redis本身支持分布式生产环境还在使用codis？","slug":"Redis单机版本框架","published":1,"updated":"2019-02-19T05:14:59.645Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsbcaud60001zlfylx3mxqpn","content":"<h2 id=\"Redis主流程伪代码\"><a href=\"#Redis主流程伪代码\" class=\"headerlink\" title=\"Redis主流程伪代码\"></a>Redis主流程伪代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def main():</span><br><span class=\"line\"> init_server()</span><br><span class=\"line\"> </span><br><span class=\"line\"> while server_is_not_shutdown():</span><br><span class=\"line\">       time = aeSearchNearestTimer()</span><br><span class=\"line\">       beforeSleep()</span><br><span class=\"line\">       aeApiPoll(time)</span><br><span class=\"line\">       processFileEvents()</span><br><span class=\"line\">       processTimeEvents()</span><br><span class=\"line\"> </span><br><span class=\"line\"> clean_server()</span><br></pre></td></tr></table></figure>\n<h2 id=\"Redis-main函数调用流程图及关键节点\"><a href=\"#Redis-main函数调用流程图及关键节点\" class=\"headerlink\" title=\"Redis main函数调用流程图及关键节点\"></a>Redis main函数调用流程图及关键节点</h2><p><img src=\"/img/rs1.jpg\" alt=\"call\"></p>\n<h2 id=\"一条简单的set命令的执行流程\"><a href=\"#一条简单的set命令的执行流程\" class=\"headerlink\" title=\"一条简单的set命令的执行流程\"></a>一条简单的set命令的执行流程</h2><p><img src=\"/img/rs2.jpg\" alt=\"flow\"></p>\n<h2 id=\"serverCron函数的功能\"><a href=\"#serverCron函数的功能\" class=\"headerlink\" title=\"serverCron函数的功能\"></a>serverCron函数的功能</h2><p><img src=\"/img/rs3.jpg\" alt=\"flow\"></p>\n<h2 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h2><p>1.bgsave执行时再次执行bgsave如何处理？</p>\n<p>直接返回,返回信息会通知正在执行.</p>\n<p>如果在aof rewrite时执行bgsave,会直接返回不能执行.</p>\n<p>看代码此处应该有bgsave schedule命令,如果此时在执行aof rewrite,则会在aof结束后在serverCron中执行。</p>\n<p>代码如下 </p>\n<p><img src=\"/img/rs4.png\" alt=\"flow\"></p>\n<p>2.aof rewrite正在执行时再次发送bgrewriteaof会如何处理?</p>\n<p>直接返回,返回信息通知正在执行</p>\n<p>如果此时在执行rdbsave,则会在serverCron中在rdbsave结束之后执行aof rewrite.</p>\n<p>代码如下:</p>\n<p><img src=\"/img/rs5.png\" alt=\"flow\"></p>\n<p>3.bgsave时如果master还在执行写入,由于linux COW机制,此时会给子进程拷贝一份数据,导致双倍内存。</p>\n<p> 待在测试环境验证是否会出现</p>\n<p>4.client端发送的命令能否在server端保证顺序?</p>\n<p>5.为什么redis本身支持分布式生产环境还在使用codis？</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Redis主流程伪代码\"><a href=\"#Redis主流程伪代码\" class=\"headerlink\" title=\"Redis主流程伪代码\"></a>Redis主流程伪代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def main():</span><br><span class=\"line\"> init_server()</span><br><span class=\"line\"> </span><br><span class=\"line\"> while server_is_not_shutdown():</span><br><span class=\"line\">       time = aeSearchNearestTimer()</span><br><span class=\"line\">       beforeSleep()</span><br><span class=\"line\">       aeApiPoll(time)</span><br><span class=\"line\">       processFileEvents()</span><br><span class=\"line\">       processTimeEvents()</span><br><span class=\"line\"> </span><br><span class=\"line\"> clean_server()</span><br></pre></td></tr></table></figure>\n<h2 id=\"Redis-main函数调用流程图及关键节点\"><a href=\"#Redis-main函数调用流程图及关键节点\" class=\"headerlink\" title=\"Redis main函数调用流程图及关键节点\"></a>Redis main函数调用流程图及关键节点</h2><p><img src=\"/img/rs1.jpg\" alt=\"call\"></p>\n<h2 id=\"一条简单的set命令的执行流程\"><a href=\"#一条简单的set命令的执行流程\" class=\"headerlink\" title=\"一条简单的set命令的执行流程\"></a>一条简单的set命令的执行流程</h2><p><img src=\"/img/rs2.jpg\" alt=\"flow\"></p>\n<h2 id=\"serverCron函数的功能\"><a href=\"#serverCron函数的功能\" class=\"headerlink\" title=\"serverCron函数的功能\"></a>serverCron函数的功能</h2><p><img src=\"/img/rs3.jpg\" alt=\"flow\"></p>\n<h2 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h2><p>1.bgsave执行时再次执行bgsave如何处理？</p>\n<p>直接返回,返回信息会通知正在执行.</p>\n<p>如果在aof rewrite时执行bgsave,会直接返回不能执行.</p>\n<p>看代码此处应该有bgsave schedule命令,如果此时在执行aof rewrite,则会在aof结束后在serverCron中执行。</p>\n<p>代码如下 </p>\n<p><img src=\"/img/rs4.png\" alt=\"flow\"></p>\n<p>2.aof rewrite正在执行时再次发送bgrewriteaof会如何处理?</p>\n<p>直接返回,返回信息通知正在执行</p>\n<p>如果此时在执行rdbsave,则会在serverCron中在rdbsave结束之后执行aof rewrite.</p>\n<p>代码如下:</p>\n<p><img src=\"/img/rs5.png\" alt=\"flow\"></p>\n<p>3.bgsave时如果master还在执行写入,由于linux COW机制,此时会给子进程拷贝一份数据,导致双倍内存。</p>\n<p> 待在测试环境验证是否会出现</p>\n<p>4.client端发送的命令能否在server端保证顺序?</p>\n<p>5.为什么redis本身支持分布式生产环境还在使用codis？</p>\n"},{"title":"Redis 懒删除(lazy free)简史","date":"2018-12-15T05:29:12.000Z","_content":"## Redis是单进程单线程模式吗\n\n下图为Redis5.0启动之后的效果。LWP为线程ID，NLWP为线程数量。可以看到，5.0的redis server共有四个线程，一个主线程48684，三个bio(background IO,后台io任务)线程，三个后台线程分别执行不同的io任务，我们重点考察删除一个key时的io线程执行。\n\n![process](/img/rl1.png)\n\nRedis增加了异步删除命令unlink,防止删除大key时阻塞主线程。其原理为执行unlink时会将需要删除的数据挂到一个链表中，由专门的线程负责将其删除。而原来的del命令还是阻塞的。我们通过对一个有1000万条数据的集合分别执行del和unlink来观察其效果。\n\n## 看一个大集合的删除\n首先通过脚本生成一个有1000万个元素的集合testset，然后通过del命令删除，如下：\n\n```\n127.0.0.1:8888>info//首先调用info命令查看内存消耗：\n \n# Memory\nused_memory:857536\nused_memory_human:837.44K\n \n127.0.0.1:8888> eval \"local i = tonumber(ARGV[1]);local res;math.randomseed(tonumber(ARGV[2]));while (i > 0) do res = redis.call('sadd',KEYS[1],math.random());i = i-1;end\" 1  testset 10000000 2\n(nil)\n(18.51s)//创建耗时18.51s \n \n127.0.0.1:8888>info//再次查看内存消耗\n# Memory\nused_memory:681063080\nused_memory_human:649.51M\n\n127.0.0.1:8888> scard testset//查看集合中元素数量\n(integer) 9976638 //通过math.random()生成，由于集合中不能有重复数据，可以看到，最终只有9976638条数据不重复。\n127.0.0.1:8888> sscan testset 0 //查看集合中的元素内容\n1) \"3670016\"\n2)  1) \"0.94438312106969913\"\n    2) \"0.55726669754705704\"\n    3) \"0.3246220281927949\"\n    4) \"0.51470726752407259\"\n    5) \"0.33469647464095453\"\n    6) \"0.48387842554779648\"\n    7) \"0.3680923377946449\"\n    8) \"0.34466382877187052\"\n    9) \"0.019202849370987551\"\n   10) \"0.71412580307299545\"\n   11) \"0.12846412375963484\"\n   12) \"0.10548432828182557\"\n\n127.0.0.1:8888> del testset //调用del命令删除，耗时2.76s \n(integer) 1\n(2.76s) \n \n127.0.0.1:8888>info//再次查看内存消耗\n# Memory\nused_memory:858568\nused_memory_human:838.45K\n```\n\n重新做上边的实验,这次试用unlink来删除。\n\n```\n\n127.0.0.1:8888> unlink testset//unlink瞬间返回\n(integer) 1\n127.0.0.1:8888>info//再次查看内存消耗。可以看到，返回之后testset并没有清理干净。内存仍然占用了大约一半，再经过1-2s,会清理干净\n# Memory\nused_memory:326898224\nused_memory_human:311.75M\n```\n\n## 尝试渐进式删除\n参见:http://antirez.com/news/93\n\n为了解决这个问题，Redis作者Antirez首先考虑的是通过渐进式删除来解决。Redis也在很多地方用到了渐进式的策略，例如 lru eviction,key 过期以及渐进式rehash.原文如下：\n\n```\nSo this was the first thing I tried: create a new timer function, and perform the eviction there. Objects were just queued into a linked list, to be reclaimed slowly and incrementally each time the timer function was called. This requires some trick to work well. For example objects implemented with hash tables were also reclaimed incrementally using the same mechanism used inside Redis SCAN command: taking a cursor inside the dictionary and iterating it to free element after element. This way, in each timer call, we don’t have to free a whole hash table. The cursor will tell us where we left when we re-enter the timer function.\n```\n\n大意就是把要删除的对象放到一个链表中，起一个定期任务，每次只删除其中一部分。\n\n这会有什么问题呢，仍然看原文中说的一种案例:\n\n```\n    WHILE 1\n        SADD myset element1 element2 … many many many elements\n        DEL myset\n    END\n```\n\n如果删除没有增加快，上边这种案例会导致内存暴涨.(虽然不知道什么情况下会有这种案例发生)。于是作者开始设计一种自适应性的删除,即通过判断内存是增加还是减少，来动态调整删除任务执行的频率，代码示例如下：\n\n\n```\n /* Compute the memory trend, biased towards thinking memory is raising\n     * for a few calls every time previous and current memory raise. */\n\t\n\t//只要内存有一次显示是增加的趋势，则接下来即使内存不再增加，还是会有连续六次mem_is_raising都是1，即判断为增加。\n\t//注意mem_is_raising的值是根据mem_trend和0.1来比较。即第一次0.9,第二次为0.9*0.9,第三次为0.81*0.81.第六次之后才会小于0.1\n\t//这也就是上边注释描述的会偏向于认为只要有一次内存是增加的，就会连续几次加快执行调用删除任务的频率\n    if (prev_mem < mem) mem_trend = 1; \n    mem_trend *= 0.9; /* Make it slowly forget. */\n    int mem_is_raising = mem_trend > .1;\n\n\t//删除一些数据\n    /* Free a few items. */\n    size_t workdone = lazyfreeStep(LAZYFREE_STEP_SLOW);\n\n\t//动态调整执行频率\n    /* Adjust this timer call frequency according to the current state. */\n    if (workdone) {\n        if (timer_period == 1000) timer_period = 20;\n        if (mem_is_raising && timer_period > 3)//如果内存在增加，就加大执行频率\n            timer_period--; /* Raise call frequency. */\n        else if (!mem_is_raising && timer_period < 20)\n            timer_period++; /* Lower call frequency. *///否则减小频率\n    } else {\n        timer_period = 1000;    /* 1 HZ */\n    }\n```\n\n这种方法有个缺陷，因为毕竟是在一个线程中，当回收的特别频繁时，会降低redis的qps,qps只能达到正常情况下的65%.\n\n\n```\nwhen the lazy free cycle was very busy, operations per second were reduced to around 65% of the norm\n```\n\n于是redis作者antirez开始考虑异步线程回收。\n\n## 异步线程\n### 异步线程为何不能有共享数据\n共享数据越多，多线程之间发生争用的可能性越大。所以为了性能，必须首先将共享数据消灭掉。\n\n那么redis在什么地方会用到共享数据呢\n\n### 如何共享\n如下代码示例为Redis2.8.24.\n\n先看执行sadd时底层数据是如何保存的\n\n```\nsadd testset val1\n```\n底层保存如下(gdb过程如下，比较晦涩,参考下文解释)：\n\n```\n254\t    set = lookupKeyWrite(c->db,c->argv[1]);\n(gdb) n\n255\t    if (set == NULL) {\n(gdb) p c->argv[1]\n$1 = (robj *) 0x7f58e3ccfcc0\n(gdb) p *c->argv[1]\n$2 = {type = 0, encoding = 0, lru = 1367521, refcount = 1, ptr = 0x7f58e3ccfcd8}\n\n(gdb) p (char *)c->argv[1].ptr //client中的argv是一个个robj,argv[1]的ptr中存储着key值'testset'\n$4 = 0x7f58e3ccfcd8 \"testset\"\n(gdb) n\n254\t    set = lookupKeyWrite(c->db,c->argv[1]);\n(gdb) n\n255\t    if (set == NULL) {\n...\n(gdb) p (char *)((robj *)((dict *)set.ptr).ht[0].table[3].key).ptr\n$37 = 0x7f58e3ccfcb8 \"val1\" //值val1保存在一个dict中，dict保存着一个个dictEntry,dictEntry的key是一个指针，指向一个robj,robj中是具体的值\n```\n\n通过下文结构体讲解，可以看下sadd testset val1,testset和val1保存在什么地方\n\n\n```\ntypedef struct dict {\n    dictType *type;\n    void *privdata;\n    dictht ht[2];\n    long rehashidx; /* rehashing not in progress if rehashidx == -1 */\n    int iterators; /* number of iterators currently running */\n} dict;\n\n\n \ntypedef struct dictht {\n    dictEntry **table;\n    unsigned long size;\n    unsigned long sizemask;\n    unsigned long used;\n} dictht;\n\ntypedef struct dictEntry {\n    void *key;\n    union {\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n        double d;\n    } v;\n    struct dictEntry *next;\n} dictEntry;\n \ntypedef struct redisObject {\n    unsigned type:4;\n    unsigned encoding:4;\n    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */\n    int refcount;\n    void *ptr;\n} robj;\n\n```\n\n* 首先所有的key保存在一个dict.ht[0]的dictht结构体中。通过上边的结构体看到，dictht中的table是一个dictEntry二级指针。\n\n* 执行sadd testset val1时，testset是其中一个dictEntry中的key,key是一个void*指针，实际存储情况为testset保存为一个char *类型\n\n* 假设testset经过哈希之后index为3，则dict.ht[0].table[3].key为testset,dict.ht[0].table[3].v.val为一个void*指针，实际存储一个robj *类型\n\n* 第三步中的robj中有个ptr指针，指向一个dict类型。dict中的其中一个entry的key指向另一个robj指针，该指针的ptr指向val\n\n即获取一个值的流程为：\n\n    key -> value_obj -> hash table -> robj -> sds_string\n然后看两个共享对象的典型场景：\n\n1.sunionstore命令\n\n看下代码实现：\n\n```\n\nint setTypeAdd(robj *subject, robj *value) {\n\t...\n    if (subject->encoding == REDIS_ENCODING_HT) {\n        if (dictAdd(subject->ptr,value,NULL) == DICT_OK) {\n            incrRefCount(value);//此处的value值由于是从已存在的集合中直接取出，refcount已经是1，此处并没有新建robj,而是直接将引用计数加1\n            return 1;\n        }\n    } \n\t...\n}\n```\n\n执行以下命令：\n\nsadd testset1 value2\n\nsunionstore set testset1 testset2 //即将testset1和testset2的元素取并集并保存到set中\n\n然后我们可以通过查看testset的元素，看看其引用计数是否变为了2\n\nsmembers testset\n\n```\n\n(gdb) p *(robj *)(((dict *)setobj.ptr).ht[0].table[3].key)\n$88 = {type = 0, encoding = 0, lru = 1457112, refcount = 2, ptr = 0x7f58e3ccfb68} //refcount为2\n \n(gdb) p (char *)(((robj *)(((dict *)setobj.ptr).ht[0].table[3].key)).ptr)\n$89 = 0x7f58e3ccfb68 \"val\"                                  //值为val\n```\n\n2.smembers命令\n\n返回元素的时候，重点看返回时的代码\n\n```\n\n/* Add a Redis Object as a bulk reply */\nvoid addReplyBulk(redisClient *c, robj *obj) {\n    addReplyBulkLen(c,obj);\n    addReply(c,obj);\n    addReply(c,shared.crlf);\n}\n```\n\n会直接将robj对象作为返回参数\n\n并且客户端传入参数也是一个个robj对象，会直接作为值保存到对象中\n\n\n### 共享时如何删除\n那么，共享对象在单线程情况下是如何删除的呢？\n\n看看del命令的实现\n\ndel调用dictDelete，最终调用每个数据类型自己的析构函数\n\n```\ndictFreeKey(d, he);\ndictFreeVal(d, he);\n```\n集合类型调用如下函数\n\n```\nvoid dictRedisObjectDestructor(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n\n    if (val == NULL) return; /* Values of swapped out keys as set to NULL */\n    decrRefCount(val);\n}\n```\n\n可以看到，只是将值的refcount减1\n如何解决共享数据\n新版本如何解决了共享数据\n\n还是通过sunionstore和smembers命令看下这两处如何解决共享：\n\n以下代码使用redis 5.0.3版本介绍：\n\n```\nvoid saddCommand(client *c) {\n    ...\n    for (j = 2; j < c->argc; j++) {\n        if (setTypeAdd(set,c->argv[j]->ptr)) added++; //sadd的时候元素也变为了c->argv[j]->ptr,一个字符串\n    }\n\t...\n}\n \nint setTypeAdd(robj *subject, sds value) {//value是一个sds\n    long long llval;\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        dict *ht = subject->ptr;\n        dictEntry *de = dictAddRaw(ht,value,NULL);\n        if (de) {\n            dictSetKey(ht,de,sdsdup(value));\n            dictSetVal(ht,de,NULL);\n            return 1;\n        }\n    }\n    return 0;\n}\n```\n增加值的时候已经变为了一个sds.\n\n现在的保存结构为：\n\n    key -> value_obj -> hash table -> sds_string\n而返回到客户端的时候也变为了一个sds,如下：\n\n```\n\naddReplyBulkCBuffer(c,elesds,sdslen(elesds));\n\nvoid addReplyBulkCBuffer(client *c, const void *p, size_t len) {\n    addReplyLongLongWithPrefix(c,len,'$');\n    addReplyString(c,p,len);\n    addReply(c,shared.crlf);\n}\n```\n\n### 效果如何\n效果如何呢？\n\n首先取值的时候从robj的间接引用变为了一个sds的直接引用。\n\n其次减少了共享会增加内存的消耗，而使用了sds之后，每个sds的内存占用会比一个robj要小。我们看下antirez如何评价这个修改：\n\n```\n\nThe result is that Redis is now more memory efficient since there are no robj structures around in the implementation of the data structures (but they are used in the code paths where there is a lot of sharing going on, for example during the command dispatch and replication). \n...\nBut, the most interesting thing is, Redis is now faster in all the operations I tested so far. Less indirection was a real winner here. It is faster even in unrelated benchmarks just because the client output buffers are now simpler and faster.\n```\n\n说了两层意思，一是内存使用更加高效了\n\n二是更少的间接引用导致redis比以前更加快，而且客户端输出更加简洁和快速。\n\n## 异步线程\n异步线程的实现以后在详细描述\n\n问题\n\n1.多线程之间在堆上分配内存时会有争用。但是antirez说因为redis在内存分配上使用的时间极少，可以忽略这种情况。\n\n如何考虑这个问题？\n\n参考：https://software.intel.com/zh-cn/articles/avoiding-heap-contention-among-threads","source":"_posts/Redis-懒删除-lazy-free-简史.md","raw":"---\ntitle: Redis 懒删除(lazy free)简史\ndate: 2018-12-15 13:29:12\ntags:\n---\n## Redis是单进程单线程模式吗\n\n下图为Redis5.0启动之后的效果。LWP为线程ID，NLWP为线程数量。可以看到，5.0的redis server共有四个线程，一个主线程48684，三个bio(background IO,后台io任务)线程，三个后台线程分别执行不同的io任务，我们重点考察删除一个key时的io线程执行。\n\n![process](/img/rl1.png)\n\nRedis增加了异步删除命令unlink,防止删除大key时阻塞主线程。其原理为执行unlink时会将需要删除的数据挂到一个链表中，由专门的线程负责将其删除。而原来的del命令还是阻塞的。我们通过对一个有1000万条数据的集合分别执行del和unlink来观察其效果。\n\n## 看一个大集合的删除\n首先通过脚本生成一个有1000万个元素的集合testset，然后通过del命令删除，如下：\n\n```\n127.0.0.1:8888>info//首先调用info命令查看内存消耗：\n \n# Memory\nused_memory:857536\nused_memory_human:837.44K\n \n127.0.0.1:8888> eval \"local i = tonumber(ARGV[1]);local res;math.randomseed(tonumber(ARGV[2]));while (i > 0) do res = redis.call('sadd',KEYS[1],math.random());i = i-1;end\" 1  testset 10000000 2\n(nil)\n(18.51s)//创建耗时18.51s \n \n127.0.0.1:8888>info//再次查看内存消耗\n# Memory\nused_memory:681063080\nused_memory_human:649.51M\n\n127.0.0.1:8888> scard testset//查看集合中元素数量\n(integer) 9976638 //通过math.random()生成，由于集合中不能有重复数据，可以看到，最终只有9976638条数据不重复。\n127.0.0.1:8888> sscan testset 0 //查看集合中的元素内容\n1) \"3670016\"\n2)  1) \"0.94438312106969913\"\n    2) \"0.55726669754705704\"\n    3) \"0.3246220281927949\"\n    4) \"0.51470726752407259\"\n    5) \"0.33469647464095453\"\n    6) \"0.48387842554779648\"\n    7) \"0.3680923377946449\"\n    8) \"0.34466382877187052\"\n    9) \"0.019202849370987551\"\n   10) \"0.71412580307299545\"\n   11) \"0.12846412375963484\"\n   12) \"0.10548432828182557\"\n\n127.0.0.1:8888> del testset //调用del命令删除，耗时2.76s \n(integer) 1\n(2.76s) \n \n127.0.0.1:8888>info//再次查看内存消耗\n# Memory\nused_memory:858568\nused_memory_human:838.45K\n```\n\n重新做上边的实验,这次试用unlink来删除。\n\n```\n\n127.0.0.1:8888> unlink testset//unlink瞬间返回\n(integer) 1\n127.0.0.1:8888>info//再次查看内存消耗。可以看到，返回之后testset并没有清理干净。内存仍然占用了大约一半，再经过1-2s,会清理干净\n# Memory\nused_memory:326898224\nused_memory_human:311.75M\n```\n\n## 尝试渐进式删除\n参见:http://antirez.com/news/93\n\n为了解决这个问题，Redis作者Antirez首先考虑的是通过渐进式删除来解决。Redis也在很多地方用到了渐进式的策略，例如 lru eviction,key 过期以及渐进式rehash.原文如下：\n\n```\nSo this was the first thing I tried: create a new timer function, and perform the eviction there. Objects were just queued into a linked list, to be reclaimed slowly and incrementally each time the timer function was called. This requires some trick to work well. For example objects implemented with hash tables were also reclaimed incrementally using the same mechanism used inside Redis SCAN command: taking a cursor inside the dictionary and iterating it to free element after element. This way, in each timer call, we don’t have to free a whole hash table. The cursor will tell us where we left when we re-enter the timer function.\n```\n\n大意就是把要删除的对象放到一个链表中，起一个定期任务，每次只删除其中一部分。\n\n这会有什么问题呢，仍然看原文中说的一种案例:\n\n```\n    WHILE 1\n        SADD myset element1 element2 … many many many elements\n        DEL myset\n    END\n```\n\n如果删除没有增加快，上边这种案例会导致内存暴涨.(虽然不知道什么情况下会有这种案例发生)。于是作者开始设计一种自适应性的删除,即通过判断内存是增加还是减少，来动态调整删除任务执行的频率，代码示例如下：\n\n\n```\n /* Compute the memory trend, biased towards thinking memory is raising\n     * for a few calls every time previous and current memory raise. */\n\t\n\t//只要内存有一次显示是增加的趋势，则接下来即使内存不再增加，还是会有连续六次mem_is_raising都是1，即判断为增加。\n\t//注意mem_is_raising的值是根据mem_trend和0.1来比较。即第一次0.9,第二次为0.9*0.9,第三次为0.81*0.81.第六次之后才会小于0.1\n\t//这也就是上边注释描述的会偏向于认为只要有一次内存是增加的，就会连续几次加快执行调用删除任务的频率\n    if (prev_mem < mem) mem_trend = 1; \n    mem_trend *= 0.9; /* Make it slowly forget. */\n    int mem_is_raising = mem_trend > .1;\n\n\t//删除一些数据\n    /* Free a few items. */\n    size_t workdone = lazyfreeStep(LAZYFREE_STEP_SLOW);\n\n\t//动态调整执行频率\n    /* Adjust this timer call frequency according to the current state. */\n    if (workdone) {\n        if (timer_period == 1000) timer_period = 20;\n        if (mem_is_raising && timer_period > 3)//如果内存在增加，就加大执行频率\n            timer_period--; /* Raise call frequency. */\n        else if (!mem_is_raising && timer_period < 20)\n            timer_period++; /* Lower call frequency. *///否则减小频率\n    } else {\n        timer_period = 1000;    /* 1 HZ */\n    }\n```\n\n这种方法有个缺陷，因为毕竟是在一个线程中，当回收的特别频繁时，会降低redis的qps,qps只能达到正常情况下的65%.\n\n\n```\nwhen the lazy free cycle was very busy, operations per second were reduced to around 65% of the norm\n```\n\n于是redis作者antirez开始考虑异步线程回收。\n\n## 异步线程\n### 异步线程为何不能有共享数据\n共享数据越多，多线程之间发生争用的可能性越大。所以为了性能，必须首先将共享数据消灭掉。\n\n那么redis在什么地方会用到共享数据呢\n\n### 如何共享\n如下代码示例为Redis2.8.24.\n\n先看执行sadd时底层数据是如何保存的\n\n```\nsadd testset val1\n```\n底层保存如下(gdb过程如下，比较晦涩,参考下文解释)：\n\n```\n254\t    set = lookupKeyWrite(c->db,c->argv[1]);\n(gdb) n\n255\t    if (set == NULL) {\n(gdb) p c->argv[1]\n$1 = (robj *) 0x7f58e3ccfcc0\n(gdb) p *c->argv[1]\n$2 = {type = 0, encoding = 0, lru = 1367521, refcount = 1, ptr = 0x7f58e3ccfcd8}\n\n(gdb) p (char *)c->argv[1].ptr //client中的argv是一个个robj,argv[1]的ptr中存储着key值'testset'\n$4 = 0x7f58e3ccfcd8 \"testset\"\n(gdb) n\n254\t    set = lookupKeyWrite(c->db,c->argv[1]);\n(gdb) n\n255\t    if (set == NULL) {\n...\n(gdb) p (char *)((robj *)((dict *)set.ptr).ht[0].table[3].key).ptr\n$37 = 0x7f58e3ccfcb8 \"val1\" //值val1保存在一个dict中，dict保存着一个个dictEntry,dictEntry的key是一个指针，指向一个robj,robj中是具体的值\n```\n\n通过下文结构体讲解，可以看下sadd testset val1,testset和val1保存在什么地方\n\n\n```\ntypedef struct dict {\n    dictType *type;\n    void *privdata;\n    dictht ht[2];\n    long rehashidx; /* rehashing not in progress if rehashidx == -1 */\n    int iterators; /* number of iterators currently running */\n} dict;\n\n\n \ntypedef struct dictht {\n    dictEntry **table;\n    unsigned long size;\n    unsigned long sizemask;\n    unsigned long used;\n} dictht;\n\ntypedef struct dictEntry {\n    void *key;\n    union {\n        void *val;\n        uint64_t u64;\n        int64_t s64;\n        double d;\n    } v;\n    struct dictEntry *next;\n} dictEntry;\n \ntypedef struct redisObject {\n    unsigned type:4;\n    unsigned encoding:4;\n    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */\n    int refcount;\n    void *ptr;\n} robj;\n\n```\n\n* 首先所有的key保存在一个dict.ht[0]的dictht结构体中。通过上边的结构体看到，dictht中的table是一个dictEntry二级指针。\n\n* 执行sadd testset val1时，testset是其中一个dictEntry中的key,key是一个void*指针，实际存储情况为testset保存为一个char *类型\n\n* 假设testset经过哈希之后index为3，则dict.ht[0].table[3].key为testset,dict.ht[0].table[3].v.val为一个void*指针，实际存储一个robj *类型\n\n* 第三步中的robj中有个ptr指针，指向一个dict类型。dict中的其中一个entry的key指向另一个robj指针，该指针的ptr指向val\n\n即获取一个值的流程为：\n\n    key -> value_obj -> hash table -> robj -> sds_string\n然后看两个共享对象的典型场景：\n\n1.sunionstore命令\n\n看下代码实现：\n\n```\n\nint setTypeAdd(robj *subject, robj *value) {\n\t...\n    if (subject->encoding == REDIS_ENCODING_HT) {\n        if (dictAdd(subject->ptr,value,NULL) == DICT_OK) {\n            incrRefCount(value);//此处的value值由于是从已存在的集合中直接取出，refcount已经是1，此处并没有新建robj,而是直接将引用计数加1\n            return 1;\n        }\n    } \n\t...\n}\n```\n\n执行以下命令：\n\nsadd testset1 value2\n\nsunionstore set testset1 testset2 //即将testset1和testset2的元素取并集并保存到set中\n\n然后我们可以通过查看testset的元素，看看其引用计数是否变为了2\n\nsmembers testset\n\n```\n\n(gdb) p *(robj *)(((dict *)setobj.ptr).ht[0].table[3].key)\n$88 = {type = 0, encoding = 0, lru = 1457112, refcount = 2, ptr = 0x7f58e3ccfb68} //refcount为2\n \n(gdb) p (char *)(((robj *)(((dict *)setobj.ptr).ht[0].table[3].key)).ptr)\n$89 = 0x7f58e3ccfb68 \"val\"                                  //值为val\n```\n\n2.smembers命令\n\n返回元素的时候，重点看返回时的代码\n\n```\n\n/* Add a Redis Object as a bulk reply */\nvoid addReplyBulk(redisClient *c, robj *obj) {\n    addReplyBulkLen(c,obj);\n    addReply(c,obj);\n    addReply(c,shared.crlf);\n}\n```\n\n会直接将robj对象作为返回参数\n\n并且客户端传入参数也是一个个robj对象，会直接作为值保存到对象中\n\n\n### 共享时如何删除\n那么，共享对象在单线程情况下是如何删除的呢？\n\n看看del命令的实现\n\ndel调用dictDelete，最终调用每个数据类型自己的析构函数\n\n```\ndictFreeKey(d, he);\ndictFreeVal(d, he);\n```\n集合类型调用如下函数\n\n```\nvoid dictRedisObjectDestructor(void *privdata, void *val)\n{\n    DICT_NOTUSED(privdata);\n\n    if (val == NULL) return; /* Values of swapped out keys as set to NULL */\n    decrRefCount(val);\n}\n```\n\n可以看到，只是将值的refcount减1\n如何解决共享数据\n新版本如何解决了共享数据\n\n还是通过sunionstore和smembers命令看下这两处如何解决共享：\n\n以下代码使用redis 5.0.3版本介绍：\n\n```\nvoid saddCommand(client *c) {\n    ...\n    for (j = 2; j < c->argc; j++) {\n        if (setTypeAdd(set,c->argv[j]->ptr)) added++; //sadd的时候元素也变为了c->argv[j]->ptr,一个字符串\n    }\n\t...\n}\n \nint setTypeAdd(robj *subject, sds value) {//value是一个sds\n    long long llval;\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        dict *ht = subject->ptr;\n        dictEntry *de = dictAddRaw(ht,value,NULL);\n        if (de) {\n            dictSetKey(ht,de,sdsdup(value));\n            dictSetVal(ht,de,NULL);\n            return 1;\n        }\n    }\n    return 0;\n}\n```\n增加值的时候已经变为了一个sds.\n\n现在的保存结构为：\n\n    key -> value_obj -> hash table -> sds_string\n而返回到客户端的时候也变为了一个sds,如下：\n\n```\n\naddReplyBulkCBuffer(c,elesds,sdslen(elesds));\n\nvoid addReplyBulkCBuffer(client *c, const void *p, size_t len) {\n    addReplyLongLongWithPrefix(c,len,'$');\n    addReplyString(c,p,len);\n    addReply(c,shared.crlf);\n}\n```\n\n### 效果如何\n效果如何呢？\n\n首先取值的时候从robj的间接引用变为了一个sds的直接引用。\n\n其次减少了共享会增加内存的消耗，而使用了sds之后，每个sds的内存占用会比一个robj要小。我们看下antirez如何评价这个修改：\n\n```\n\nThe result is that Redis is now more memory efficient since there are no robj structures around in the implementation of the data structures (but they are used in the code paths where there is a lot of sharing going on, for example during the command dispatch and replication). \n...\nBut, the most interesting thing is, Redis is now faster in all the operations I tested so far. Less indirection was a real winner here. It is faster even in unrelated benchmarks just because the client output buffers are now simpler and faster.\n```\n\n说了两层意思，一是内存使用更加高效了\n\n二是更少的间接引用导致redis比以前更加快，而且客户端输出更加简洁和快速。\n\n## 异步线程\n异步线程的实现以后在详细描述\n\n问题\n\n1.多线程之间在堆上分配内存时会有争用。但是antirez说因为redis在内存分配上使用的时间极少，可以忽略这种情况。\n\n如何考虑这个问题？\n\n参考：https://software.intel.com/zh-cn/articles/avoiding-heap-contention-among-threads","slug":"Redis-懒删除-lazy-free-简史","published":1,"updated":"2019-02-19T05:40:04.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsbcaudt0002zlfyjdezf9nk","content":"<h2 id=\"Redis是单进程单线程模式吗\"><a href=\"#Redis是单进程单线程模式吗\" class=\"headerlink\" title=\"Redis是单进程单线程模式吗\"></a>Redis是单进程单线程模式吗</h2><p>下图为Redis5.0启动之后的效果。LWP为线程ID，NLWP为线程数量。可以看到，5.0的redis server共有四个线程，一个主线程48684，三个bio(background IO,后台io任务)线程，三个后台线程分别执行不同的io任务，我们重点考察删除一个key时的io线程执行。</p>\n<p><img src=\"/img/rl1.png\" alt=\"process\"></p>\n<p>Redis增加了异步删除命令unlink,防止删除大key时阻塞主线程。其原理为执行unlink时会将需要删除的数据挂到一个链表中，由专门的线程负责将其删除。而原来的del命令还是阻塞的。我们通过对一个有1000万条数据的集合分别执行del和unlink来观察其效果。</p>\n<h2 id=\"看一个大集合的删除\"><a href=\"#看一个大集合的删除\" class=\"headerlink\" title=\"看一个大集合的删除\"></a>看一个大集合的删除</h2><p>首先通过脚本生成一个有1000万个元素的集合testset，然后通过del命令删除，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:8888&gt;info//首先调用info命令查看内存消耗：</span><br><span class=\"line\"> </span><br><span class=\"line\"># Memory</span><br><span class=\"line\">used_memory:857536</span><br><span class=\"line\">used_memory_human:837.44K</span><br><span class=\"line\"> </span><br><span class=\"line\">127.0.0.1:8888&gt; eval &quot;local i = tonumber(ARGV[1]);local res;math.randomseed(tonumber(ARGV[2]));while (i &gt; 0) do res = redis.call(&apos;sadd&apos;,KEYS[1],math.random());i = i-1;end&quot; 1  testset 10000000 2</span><br><span class=\"line\">(nil)</span><br><span class=\"line\">(18.51s)//创建耗时18.51s </span><br><span class=\"line\"> </span><br><span class=\"line\">127.0.0.1:8888&gt;info//再次查看内存消耗</span><br><span class=\"line\"># Memory</span><br><span class=\"line\">used_memory:681063080</span><br><span class=\"line\">used_memory_human:649.51M</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:8888&gt; scard testset//查看集合中元素数量</span><br><span class=\"line\">(integer) 9976638 //通过math.random()生成，由于集合中不能有重复数据，可以看到，最终只有9976638条数据不重复。</span><br><span class=\"line\">127.0.0.1:8888&gt; sscan testset 0 //查看集合中的元素内容</span><br><span class=\"line\">1) &quot;3670016&quot;</span><br><span class=\"line\">2)  1) &quot;0.94438312106969913&quot;</span><br><span class=\"line\">    2) &quot;0.55726669754705704&quot;</span><br><span class=\"line\">    3) &quot;0.3246220281927949&quot;</span><br><span class=\"line\">    4) &quot;0.51470726752407259&quot;</span><br><span class=\"line\">    5) &quot;0.33469647464095453&quot;</span><br><span class=\"line\">    6) &quot;0.48387842554779648&quot;</span><br><span class=\"line\">    7) &quot;0.3680923377946449&quot;</span><br><span class=\"line\">    8) &quot;0.34466382877187052&quot;</span><br><span class=\"line\">    9) &quot;0.019202849370987551&quot;</span><br><span class=\"line\">   10) &quot;0.71412580307299545&quot;</span><br><span class=\"line\">   11) &quot;0.12846412375963484&quot;</span><br><span class=\"line\">   12) &quot;0.10548432828182557&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:8888&gt; del testset //调用del命令删除，耗时2.76s </span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">(2.76s) </span><br><span class=\"line\"> </span><br><span class=\"line\">127.0.0.1:8888&gt;info//再次查看内存消耗</span><br><span class=\"line\"># Memory</span><br><span class=\"line\">used_memory:858568</span><br><span class=\"line\">used_memory_human:838.45K</span><br></pre></td></tr></table></figure>\n<p>重新做上边的实验,这次试用unlink来删除。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:8888&gt; unlink testset//unlink瞬间返回</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:8888&gt;info//再次查看内存消耗。可以看到，返回之后testset并没有清理干净。内存仍然占用了大约一半，再经过1-2s,会清理干净</span><br><span class=\"line\"># Memory</span><br><span class=\"line\">used_memory:326898224</span><br><span class=\"line\">used_memory_human:311.75M</span><br></pre></td></tr></table></figure>\n<h2 id=\"尝试渐进式删除\"><a href=\"#尝试渐进式删除\" class=\"headerlink\" title=\"尝试渐进式删除\"></a>尝试渐进式删除</h2><p>参见:<a href=\"http://antirez.com/news/93\" target=\"_blank\" rel=\"noopener\">http://antirez.com/news/93</a></p>\n<p>为了解决这个问题，Redis作者Antirez首先考虑的是通过渐进式删除来解决。Redis也在很多地方用到了渐进式的策略，例如 lru eviction,key 过期以及渐进式rehash.原文如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">So this was the first thing I tried: create a new timer function, and perform the eviction there. Objects were just queued into a linked list, to be reclaimed slowly and incrementally each time the timer function was called. This requires some trick to work well. For example objects implemented with hash tables were also reclaimed incrementally using the same mechanism used inside Redis SCAN command: taking a cursor inside the dictionary and iterating it to free element after element. This way, in each timer call, we don’t have to free a whole hash table. The cursor will tell us where we left when we re-enter the timer function.</span><br></pre></td></tr></table></figure>\n<p>大意就是把要删除的对象放到一个链表中，起一个定期任务，每次只删除其中一部分。</p>\n<p>这会有什么问题呢，仍然看原文中说的一种案例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WHILE 1</span><br><span class=\"line\">    SADD myset element1 element2 … many many many elements</span><br><span class=\"line\">    DEL myset</span><br><span class=\"line\">END</span><br></pre></td></tr></table></figure>\n<p>如果删除没有增加快，上边这种案例会导致内存暴涨.(虽然不知道什么情况下会有这种案例发生)。于是作者开始设计一种自适应性的删除,即通过判断内存是增加还是减少，来动态调整删除任务执行的频率，代码示例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* Compute the memory trend, biased towards thinking memory is raising</span><br><span class=\"line\">    * for a few calls every time previous and current memory raise. */</span><br><span class=\"line\"></span><br><span class=\"line\">//只要内存有一次显示是增加的趋势，则接下来即使内存不再增加，还是会有连续六次mem_is_raising都是1，即判断为增加。</span><br><span class=\"line\">//注意mem_is_raising的值是根据mem_trend和0.1来比较。即第一次0.9,第二次为0.9*0.9,第三次为0.81*0.81.第六次之后才会小于0.1</span><br><span class=\"line\">//这也就是上边注释描述的会偏向于认为只要有一次内存是增加的，就会连续几次加快执行调用删除任务的频率</span><br><span class=\"line\">   if (prev_mem &lt; mem) mem_trend = 1; </span><br><span class=\"line\">   mem_trend *= 0.9; /* Make it slowly forget. */</span><br><span class=\"line\">   int mem_is_raising = mem_trend &gt; .1;</span><br><span class=\"line\"></span><br><span class=\"line\">//删除一些数据</span><br><span class=\"line\">   /* Free a few items. */</span><br><span class=\"line\">   size_t workdone = lazyfreeStep(LAZYFREE_STEP_SLOW);</span><br><span class=\"line\"></span><br><span class=\"line\">//动态调整执行频率</span><br><span class=\"line\">   /* Adjust this timer call frequency according to the current state. */</span><br><span class=\"line\">   if (workdone) &#123;</span><br><span class=\"line\">       if (timer_period == 1000) timer_period = 20;</span><br><span class=\"line\">       if (mem_is_raising &amp;&amp; timer_period &gt; 3)//如果内存在增加，就加大执行频率</span><br><span class=\"line\">           timer_period--; /* Raise call frequency. */</span><br><span class=\"line\">       else if (!mem_is_raising &amp;&amp; timer_period &lt; 20)</span><br><span class=\"line\">           timer_period++; /* Lower call frequency. *///否则减小频率</span><br><span class=\"line\">   &#125; else &#123;</span><br><span class=\"line\">       timer_period = 1000;    /* 1 HZ */</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>这种方法有个缺陷，因为毕竟是在一个线程中，当回收的特别频繁时，会降低redis的qps,qps只能达到正常情况下的65%.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">when the lazy free cycle was very busy, operations per second were reduced to around 65% of the norm</span><br></pre></td></tr></table></figure>\n<p>于是redis作者antirez开始考虑异步线程回收。</p>\n<h2 id=\"异步线程\"><a href=\"#异步线程\" class=\"headerlink\" title=\"异步线程\"></a>异步线程</h2><h3 id=\"异步线程为何不能有共享数据\"><a href=\"#异步线程为何不能有共享数据\" class=\"headerlink\" title=\"异步线程为何不能有共享数据\"></a>异步线程为何不能有共享数据</h3><p>共享数据越多，多线程之间发生争用的可能性越大。所以为了性能，必须首先将共享数据消灭掉。</p>\n<p>那么redis在什么地方会用到共享数据呢</p>\n<h3 id=\"如何共享\"><a href=\"#如何共享\" class=\"headerlink\" title=\"如何共享\"></a>如何共享</h3><p>如下代码示例为Redis2.8.24.</p>\n<p>先看执行sadd时底层数据是如何保存的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sadd testset val1</span><br></pre></td></tr></table></figure>\n<p>底层保存如下(gdb过程如下，比较晦涩,参考下文解释)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">254\t    set = lookupKeyWrite(c-&gt;db,c-&gt;argv[1]);</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">255\t    if (set == NULL) &#123;</span><br><span class=\"line\">(gdb) p c-&gt;argv[1]</span><br><span class=\"line\">$1 = (robj *) 0x7f58e3ccfcc0</span><br><span class=\"line\">(gdb) p *c-&gt;argv[1]</span><br><span class=\"line\">$2 = &#123;type = 0, encoding = 0, lru = 1367521, refcount = 1, ptr = 0x7f58e3ccfcd8&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(gdb) p (char *)c-&gt;argv[1].ptr //client中的argv是一个个robj,argv[1]的ptr中存储着key值&apos;testset&apos;</span><br><span class=\"line\">$4 = 0x7f58e3ccfcd8 &quot;testset&quot;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">254\t    set = lookupKeyWrite(c-&gt;db,c-&gt;argv[1]);</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">255\t    if (set == NULL) &#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">(gdb) p (char *)((robj *)((dict *)set.ptr).ht[0].table[3].key).ptr</span><br><span class=\"line\">$37 = 0x7f58e3ccfcb8 &quot;val1&quot; //值val1保存在一个dict中，dict保存着一个个dictEntry,dictEntry的key是一个指针，指向一个robj,robj中是具体的值</span><br></pre></td></tr></table></figure>\n<p>通过下文结构体讲解，可以看下sadd testset val1,testset和val1保存在什么地方</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct dict &#123;</span><br><span class=\"line\">    dictType *type;</span><br><span class=\"line\">    void *privdata;</span><br><span class=\"line\">    dictht ht[2];</span><br><span class=\"line\">    long rehashidx; /* rehashing not in progress if rehashidx == -1 */</span><br><span class=\"line\">    int iterators; /* number of iterators currently running */</span><br><span class=\"line\">&#125; dict;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\">typedef struct dictht &#123;</span><br><span class=\"line\">    dictEntry **table;</span><br><span class=\"line\">    unsigned long size;</span><br><span class=\"line\">    unsigned long sizemask;</span><br><span class=\"line\">    unsigned long used;</span><br><span class=\"line\">&#125; dictht;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct dictEntry &#123;</span><br><span class=\"line\">    void *key;</span><br><span class=\"line\">    union &#123;</span><br><span class=\"line\">        void *val;</span><br><span class=\"line\">        uint64_t u64;</span><br><span class=\"line\">        int64_t s64;</span><br><span class=\"line\">        double d;</span><br><span class=\"line\">    &#125; v;</span><br><span class=\"line\">    struct dictEntry *next;</span><br><span class=\"line\">&#125; dictEntry;</span><br><span class=\"line\"> </span><br><span class=\"line\">typedef struct redisObject &#123;</span><br><span class=\"line\">    unsigned type:4;</span><br><span class=\"line\">    unsigned encoding:4;</span><br><span class=\"line\">    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */</span><br><span class=\"line\">    int refcount;</span><br><span class=\"line\">    void *ptr;</span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>首先所有的key保存在一个dict.ht[0]的dictht结构体中。通过上边的结构体看到，dictht中的table是一个dictEntry二级指针。</p>\n</li>\n<li><p>执行sadd testset val1时，testset是其中一个dictEntry中的key,key是一个void<em>指针，实际存储情况为testset保存为一个char </em>类型</p>\n</li>\n<li><p>假设testset经过哈希之后index为3，则dict.ht[0].table[3].key为testset,dict.ht[0].table[3].v.val为一个void<em>指针，实际存储一个robj </em>类型</p>\n</li>\n<li><p>第三步中的robj中有个ptr指针，指向一个dict类型。dict中的其中一个entry的key指向另一个robj指针，该指针的ptr指向val</p>\n</li>\n</ul>\n<p>即获取一个值的流程为：</p>\n<pre><code>key -&gt; value_obj -&gt; hash table -&gt; robj -&gt; sds_string\n</code></pre><p>然后看两个共享对象的典型场景：</p>\n<p>1.sunionstore命令</p>\n<p>看下代码实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">int setTypeAdd(robj *subject, robj *value) &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">    if (subject-&gt;encoding == REDIS_ENCODING_HT) &#123;</span><br><span class=\"line\">        if (dictAdd(subject-&gt;ptr,value,NULL) == DICT_OK) &#123;</span><br><span class=\"line\">            incrRefCount(value);//此处的value值由于是从已存在的集合中直接取出，refcount已经是1，此处并没有新建robj,而是直接将引用计数加1</span><br><span class=\"line\">            return 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行以下命令：</p>\n<p>sadd testset1 value2</p>\n<p>sunionstore set testset1 testset2 //即将testset1和testset2的元素取并集并保存到set中</p>\n<p>然后我们可以通过查看testset的元素，看看其引用计数是否变为了2</p>\n<p>smembers testset</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">(gdb) p *(robj *)(((dict *)setobj.ptr).ht[0].table[3].key)</span><br><span class=\"line\">$88 = &#123;type = 0, encoding = 0, lru = 1457112, refcount = 2, ptr = 0x7f58e3ccfb68&#125; //refcount为2</span><br><span class=\"line\"> </span><br><span class=\"line\">(gdb) p (char *)(((robj *)(((dict *)setobj.ptr).ht[0].table[3].key)).ptr)</span><br><span class=\"line\">$89 = 0x7f58e3ccfb68 &quot;val&quot;                                  //值为val</span><br></pre></td></tr></table></figure>\n<p>2.smembers命令</p>\n<p>返回元素的时候，重点看返回时的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/* Add a Redis Object as a bulk reply */</span><br><span class=\"line\">void addReplyBulk(redisClient *c, robj *obj) &#123;</span><br><span class=\"line\">    addReplyBulkLen(c,obj);</span><br><span class=\"line\">    addReply(c,obj);</span><br><span class=\"line\">    addReply(c,shared.crlf);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会直接将robj对象作为返回参数</p>\n<p>并且客户端传入参数也是一个个robj对象，会直接作为值保存到对象中</p>\n<h3 id=\"共享时如何删除\"><a href=\"#共享时如何删除\" class=\"headerlink\" title=\"共享时如何删除\"></a>共享时如何删除</h3><p>那么，共享对象在单线程情况下是如何删除的呢？</p>\n<p>看看del命令的实现</p>\n<p>del调用dictDelete，最终调用每个数据类型自己的析构函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dictFreeKey(d, he);</span><br><span class=\"line\">dictFreeVal(d, he);</span><br></pre></td></tr></table></figure>\n<p>集合类型调用如下函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void dictRedisObjectDestructor(void *privdata, void *val)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DICT_NOTUSED(privdata);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (val == NULL) return; /* Values of swapped out keys as set to NULL */</span><br><span class=\"line\">    decrRefCount(val);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，只是将值的refcount减1<br>如何解决共享数据<br>新版本如何解决了共享数据</p>\n<p>还是通过sunionstore和smembers命令看下这两处如何解决共享：</p>\n<p>以下代码使用redis 5.0.3版本介绍：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void saddCommand(client *c) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    for (j = 2; j &lt; c-&gt;argc; j++) &#123;</span><br><span class=\"line\">        if (setTypeAdd(set,c-&gt;argv[j]-&gt;ptr)) added++; //sadd的时候元素也变为了c-&gt;argv[j]-&gt;ptr,一个字符串</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">int setTypeAdd(robj *subject, sds value) &#123;//value是一个sds</span><br><span class=\"line\">    long long llval;</span><br><span class=\"line\">    if (subject-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class=\"line\">        dict *ht = subject-&gt;ptr;</span><br><span class=\"line\">        dictEntry *de = dictAddRaw(ht,value,NULL);</span><br><span class=\"line\">        if (de) &#123;</span><br><span class=\"line\">            dictSetKey(ht,de,sdsdup(value));</span><br><span class=\"line\">            dictSetVal(ht,de,NULL);</span><br><span class=\"line\">            return 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>增加值的时候已经变为了一个sds.</p>\n<p>现在的保存结构为：</p>\n<pre><code>key -&gt; value_obj -&gt; hash table -&gt; sds_string\n</code></pre><p>而返回到客户端的时候也变为了一个sds,如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">addReplyBulkCBuffer(c,elesds,sdslen(elesds));</span><br><span class=\"line\"></span><br><span class=\"line\">void addReplyBulkCBuffer(client *c, const void *p, size_t len) &#123;</span><br><span class=\"line\">    addReplyLongLongWithPrefix(c,len,&apos;$&apos;);</span><br><span class=\"line\">    addReplyString(c,p,len);</span><br><span class=\"line\">    addReply(c,shared.crlf);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"效果如何\"><a href=\"#效果如何\" class=\"headerlink\" title=\"效果如何\"></a>效果如何</h3><p>效果如何呢？</p>\n<p>首先取值的时候从robj的间接引用变为了一个sds的直接引用。</p>\n<p>其次减少了共享会增加内存的消耗，而使用了sds之后，每个sds的内存占用会比一个robj要小。我们看下antirez如何评价这个修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">The result is that Redis is now more memory efficient since there are no robj structures around in the implementation of the data structures (but they are used in the code paths where there is a lot of sharing going on, for example during the command dispatch and replication). </span><br><span class=\"line\">...</span><br><span class=\"line\">But, the most interesting thing is, Redis is now faster in all the operations I tested so far. Less indirection was a real winner here. It is faster even in unrelated benchmarks just because the client output buffers are now simpler and faster.</span><br></pre></td></tr></table></figure>\n<p>说了两层意思，一是内存使用更加高效了</p>\n<p>二是更少的间接引用导致redis比以前更加快，而且客户端输出更加简洁和快速。</p>\n<h2 id=\"异步线程-1\"><a href=\"#异步线程-1\" class=\"headerlink\" title=\"异步线程\"></a>异步线程</h2><p>异步线程的实现以后在详细描述</p>\n<p>问题</p>\n<p>1.多线程之间在堆上分配内存时会有争用。但是antirez说因为redis在内存分配上使用的时间极少，可以忽略这种情况。</p>\n<p>如何考虑这个问题？</p>\n<p>参考：<a href=\"https://software.intel.com/zh-cn/articles/avoiding-heap-contention-among-threads\" target=\"_blank\" rel=\"noopener\">https://software.intel.com/zh-cn/articles/avoiding-heap-contention-among-threads</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Redis是单进程单线程模式吗\"><a href=\"#Redis是单进程单线程模式吗\" class=\"headerlink\" title=\"Redis是单进程单线程模式吗\"></a>Redis是单进程单线程模式吗</h2><p>下图为Redis5.0启动之后的效果。LWP为线程ID，NLWP为线程数量。可以看到，5.0的redis server共有四个线程，一个主线程48684，三个bio(background IO,后台io任务)线程，三个后台线程分别执行不同的io任务，我们重点考察删除一个key时的io线程执行。</p>\n<p><img src=\"/img/rl1.png\" alt=\"process\"></p>\n<p>Redis增加了异步删除命令unlink,防止删除大key时阻塞主线程。其原理为执行unlink时会将需要删除的数据挂到一个链表中，由专门的线程负责将其删除。而原来的del命令还是阻塞的。我们通过对一个有1000万条数据的集合分别执行del和unlink来观察其效果。</p>\n<h2 id=\"看一个大集合的删除\"><a href=\"#看一个大集合的删除\" class=\"headerlink\" title=\"看一个大集合的删除\"></a>看一个大集合的删除</h2><p>首先通过脚本生成一个有1000万个元素的集合testset，然后通过del命令删除，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:8888&gt;info//首先调用info命令查看内存消耗：</span><br><span class=\"line\"> </span><br><span class=\"line\"># Memory</span><br><span class=\"line\">used_memory:857536</span><br><span class=\"line\">used_memory_human:837.44K</span><br><span class=\"line\"> </span><br><span class=\"line\">127.0.0.1:8888&gt; eval &quot;local i = tonumber(ARGV[1]);local res;math.randomseed(tonumber(ARGV[2]));while (i &gt; 0) do res = redis.call(&apos;sadd&apos;,KEYS[1],math.random());i = i-1;end&quot; 1  testset 10000000 2</span><br><span class=\"line\">(nil)</span><br><span class=\"line\">(18.51s)//创建耗时18.51s </span><br><span class=\"line\"> </span><br><span class=\"line\">127.0.0.1:8888&gt;info//再次查看内存消耗</span><br><span class=\"line\"># Memory</span><br><span class=\"line\">used_memory:681063080</span><br><span class=\"line\">used_memory_human:649.51M</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:8888&gt; scard testset//查看集合中元素数量</span><br><span class=\"line\">(integer) 9976638 //通过math.random()生成，由于集合中不能有重复数据，可以看到，最终只有9976638条数据不重复。</span><br><span class=\"line\">127.0.0.1:8888&gt; sscan testset 0 //查看集合中的元素内容</span><br><span class=\"line\">1) &quot;3670016&quot;</span><br><span class=\"line\">2)  1) &quot;0.94438312106969913&quot;</span><br><span class=\"line\">    2) &quot;0.55726669754705704&quot;</span><br><span class=\"line\">    3) &quot;0.3246220281927949&quot;</span><br><span class=\"line\">    4) &quot;0.51470726752407259&quot;</span><br><span class=\"line\">    5) &quot;0.33469647464095453&quot;</span><br><span class=\"line\">    6) &quot;0.48387842554779648&quot;</span><br><span class=\"line\">    7) &quot;0.3680923377946449&quot;</span><br><span class=\"line\">    8) &quot;0.34466382877187052&quot;</span><br><span class=\"line\">    9) &quot;0.019202849370987551&quot;</span><br><span class=\"line\">   10) &quot;0.71412580307299545&quot;</span><br><span class=\"line\">   11) &quot;0.12846412375963484&quot;</span><br><span class=\"line\">   12) &quot;0.10548432828182557&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:8888&gt; del testset //调用del命令删除，耗时2.76s </span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">(2.76s) </span><br><span class=\"line\"> </span><br><span class=\"line\">127.0.0.1:8888&gt;info//再次查看内存消耗</span><br><span class=\"line\"># Memory</span><br><span class=\"line\">used_memory:858568</span><br><span class=\"line\">used_memory_human:838.45K</span><br></pre></td></tr></table></figure>\n<p>重新做上边的实验,这次试用unlink来删除。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:8888&gt; unlink testset//unlink瞬间返回</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:8888&gt;info//再次查看内存消耗。可以看到，返回之后testset并没有清理干净。内存仍然占用了大约一半，再经过1-2s,会清理干净</span><br><span class=\"line\"># Memory</span><br><span class=\"line\">used_memory:326898224</span><br><span class=\"line\">used_memory_human:311.75M</span><br></pre></td></tr></table></figure>\n<h2 id=\"尝试渐进式删除\"><a href=\"#尝试渐进式删除\" class=\"headerlink\" title=\"尝试渐进式删除\"></a>尝试渐进式删除</h2><p>参见:<a href=\"http://antirez.com/news/93\" target=\"_blank\" rel=\"noopener\">http://antirez.com/news/93</a></p>\n<p>为了解决这个问题，Redis作者Antirez首先考虑的是通过渐进式删除来解决。Redis也在很多地方用到了渐进式的策略，例如 lru eviction,key 过期以及渐进式rehash.原文如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">So this was the first thing I tried: create a new timer function, and perform the eviction there. Objects were just queued into a linked list, to be reclaimed slowly and incrementally each time the timer function was called. This requires some trick to work well. For example objects implemented with hash tables were also reclaimed incrementally using the same mechanism used inside Redis SCAN command: taking a cursor inside the dictionary and iterating it to free element after element. This way, in each timer call, we don’t have to free a whole hash table. The cursor will tell us where we left when we re-enter the timer function.</span><br></pre></td></tr></table></figure>\n<p>大意就是把要删除的对象放到一个链表中，起一个定期任务，每次只删除其中一部分。</p>\n<p>这会有什么问题呢，仍然看原文中说的一种案例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WHILE 1</span><br><span class=\"line\">    SADD myset element1 element2 … many many many elements</span><br><span class=\"line\">    DEL myset</span><br><span class=\"line\">END</span><br></pre></td></tr></table></figure>\n<p>如果删除没有增加快，上边这种案例会导致内存暴涨.(虽然不知道什么情况下会有这种案例发生)。于是作者开始设计一种自适应性的删除,即通过判断内存是增加还是减少，来动态调整删除任务执行的频率，代码示例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* Compute the memory trend, biased towards thinking memory is raising</span><br><span class=\"line\">    * for a few calls every time previous and current memory raise. */</span><br><span class=\"line\"></span><br><span class=\"line\">//只要内存有一次显示是增加的趋势，则接下来即使内存不再增加，还是会有连续六次mem_is_raising都是1，即判断为增加。</span><br><span class=\"line\">//注意mem_is_raising的值是根据mem_trend和0.1来比较。即第一次0.9,第二次为0.9*0.9,第三次为0.81*0.81.第六次之后才会小于0.1</span><br><span class=\"line\">//这也就是上边注释描述的会偏向于认为只要有一次内存是增加的，就会连续几次加快执行调用删除任务的频率</span><br><span class=\"line\">   if (prev_mem &lt; mem) mem_trend = 1; </span><br><span class=\"line\">   mem_trend *= 0.9; /* Make it slowly forget. */</span><br><span class=\"line\">   int mem_is_raising = mem_trend &gt; .1;</span><br><span class=\"line\"></span><br><span class=\"line\">//删除一些数据</span><br><span class=\"line\">   /* Free a few items. */</span><br><span class=\"line\">   size_t workdone = lazyfreeStep(LAZYFREE_STEP_SLOW);</span><br><span class=\"line\"></span><br><span class=\"line\">//动态调整执行频率</span><br><span class=\"line\">   /* Adjust this timer call frequency according to the current state. */</span><br><span class=\"line\">   if (workdone) &#123;</span><br><span class=\"line\">       if (timer_period == 1000) timer_period = 20;</span><br><span class=\"line\">       if (mem_is_raising &amp;&amp; timer_period &gt; 3)//如果内存在增加，就加大执行频率</span><br><span class=\"line\">           timer_period--; /* Raise call frequency. */</span><br><span class=\"line\">       else if (!mem_is_raising &amp;&amp; timer_period &lt; 20)</span><br><span class=\"line\">           timer_period++; /* Lower call frequency. *///否则减小频率</span><br><span class=\"line\">   &#125; else &#123;</span><br><span class=\"line\">       timer_period = 1000;    /* 1 HZ */</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>这种方法有个缺陷，因为毕竟是在一个线程中，当回收的特别频繁时，会降低redis的qps,qps只能达到正常情况下的65%.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">when the lazy free cycle was very busy, operations per second were reduced to around 65% of the norm</span><br></pre></td></tr></table></figure>\n<p>于是redis作者antirez开始考虑异步线程回收。</p>\n<h2 id=\"异步线程\"><a href=\"#异步线程\" class=\"headerlink\" title=\"异步线程\"></a>异步线程</h2><h3 id=\"异步线程为何不能有共享数据\"><a href=\"#异步线程为何不能有共享数据\" class=\"headerlink\" title=\"异步线程为何不能有共享数据\"></a>异步线程为何不能有共享数据</h3><p>共享数据越多，多线程之间发生争用的可能性越大。所以为了性能，必须首先将共享数据消灭掉。</p>\n<p>那么redis在什么地方会用到共享数据呢</p>\n<h3 id=\"如何共享\"><a href=\"#如何共享\" class=\"headerlink\" title=\"如何共享\"></a>如何共享</h3><p>如下代码示例为Redis2.8.24.</p>\n<p>先看执行sadd时底层数据是如何保存的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sadd testset val1</span><br></pre></td></tr></table></figure>\n<p>底层保存如下(gdb过程如下，比较晦涩,参考下文解释)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">254\t    set = lookupKeyWrite(c-&gt;db,c-&gt;argv[1]);</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">255\t    if (set == NULL) &#123;</span><br><span class=\"line\">(gdb) p c-&gt;argv[1]</span><br><span class=\"line\">$1 = (robj *) 0x7f58e3ccfcc0</span><br><span class=\"line\">(gdb) p *c-&gt;argv[1]</span><br><span class=\"line\">$2 = &#123;type = 0, encoding = 0, lru = 1367521, refcount = 1, ptr = 0x7f58e3ccfcd8&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(gdb) p (char *)c-&gt;argv[1].ptr //client中的argv是一个个robj,argv[1]的ptr中存储着key值&apos;testset&apos;</span><br><span class=\"line\">$4 = 0x7f58e3ccfcd8 &quot;testset&quot;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">254\t    set = lookupKeyWrite(c-&gt;db,c-&gt;argv[1]);</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">255\t    if (set == NULL) &#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">(gdb) p (char *)((robj *)((dict *)set.ptr).ht[0].table[3].key).ptr</span><br><span class=\"line\">$37 = 0x7f58e3ccfcb8 &quot;val1&quot; //值val1保存在一个dict中，dict保存着一个个dictEntry,dictEntry的key是一个指针，指向一个robj,robj中是具体的值</span><br></pre></td></tr></table></figure>\n<p>通过下文结构体讲解，可以看下sadd testset val1,testset和val1保存在什么地方</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct dict &#123;</span><br><span class=\"line\">    dictType *type;</span><br><span class=\"line\">    void *privdata;</span><br><span class=\"line\">    dictht ht[2];</span><br><span class=\"line\">    long rehashidx; /* rehashing not in progress if rehashidx == -1 */</span><br><span class=\"line\">    int iterators; /* number of iterators currently running */</span><br><span class=\"line\">&#125; dict;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\">typedef struct dictht &#123;</span><br><span class=\"line\">    dictEntry **table;</span><br><span class=\"line\">    unsigned long size;</span><br><span class=\"line\">    unsigned long sizemask;</span><br><span class=\"line\">    unsigned long used;</span><br><span class=\"line\">&#125; dictht;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct dictEntry &#123;</span><br><span class=\"line\">    void *key;</span><br><span class=\"line\">    union &#123;</span><br><span class=\"line\">        void *val;</span><br><span class=\"line\">        uint64_t u64;</span><br><span class=\"line\">        int64_t s64;</span><br><span class=\"line\">        double d;</span><br><span class=\"line\">    &#125; v;</span><br><span class=\"line\">    struct dictEntry *next;</span><br><span class=\"line\">&#125; dictEntry;</span><br><span class=\"line\"> </span><br><span class=\"line\">typedef struct redisObject &#123;</span><br><span class=\"line\">    unsigned type:4;</span><br><span class=\"line\">    unsigned encoding:4;</span><br><span class=\"line\">    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */</span><br><span class=\"line\">    int refcount;</span><br><span class=\"line\">    void *ptr;</span><br><span class=\"line\">&#125; robj;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>首先所有的key保存在一个dict.ht[0]的dictht结构体中。通过上边的结构体看到，dictht中的table是一个dictEntry二级指针。</p>\n</li>\n<li><p>执行sadd testset val1时，testset是其中一个dictEntry中的key,key是一个void<em>指针，实际存储情况为testset保存为一个char </em>类型</p>\n</li>\n<li><p>假设testset经过哈希之后index为3，则dict.ht[0].table[3].key为testset,dict.ht[0].table[3].v.val为一个void<em>指针，实际存储一个robj </em>类型</p>\n</li>\n<li><p>第三步中的robj中有个ptr指针，指向一个dict类型。dict中的其中一个entry的key指向另一个robj指针，该指针的ptr指向val</p>\n</li>\n</ul>\n<p>即获取一个值的流程为：</p>\n<pre><code>key -&gt; value_obj -&gt; hash table -&gt; robj -&gt; sds_string\n</code></pre><p>然后看两个共享对象的典型场景：</p>\n<p>1.sunionstore命令</p>\n<p>看下代码实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">int setTypeAdd(robj *subject, robj *value) &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">    if (subject-&gt;encoding == REDIS_ENCODING_HT) &#123;</span><br><span class=\"line\">        if (dictAdd(subject-&gt;ptr,value,NULL) == DICT_OK) &#123;</span><br><span class=\"line\">            incrRefCount(value);//此处的value值由于是从已存在的集合中直接取出，refcount已经是1，此处并没有新建robj,而是直接将引用计数加1</span><br><span class=\"line\">            return 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行以下命令：</p>\n<p>sadd testset1 value2</p>\n<p>sunionstore set testset1 testset2 //即将testset1和testset2的元素取并集并保存到set中</p>\n<p>然后我们可以通过查看testset的元素，看看其引用计数是否变为了2</p>\n<p>smembers testset</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">(gdb) p *(robj *)(((dict *)setobj.ptr).ht[0].table[3].key)</span><br><span class=\"line\">$88 = &#123;type = 0, encoding = 0, lru = 1457112, refcount = 2, ptr = 0x7f58e3ccfb68&#125; //refcount为2</span><br><span class=\"line\"> </span><br><span class=\"line\">(gdb) p (char *)(((robj *)(((dict *)setobj.ptr).ht[0].table[3].key)).ptr)</span><br><span class=\"line\">$89 = 0x7f58e3ccfb68 &quot;val&quot;                                  //值为val</span><br></pre></td></tr></table></figure>\n<p>2.smembers命令</p>\n<p>返回元素的时候，重点看返回时的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/* Add a Redis Object as a bulk reply */</span><br><span class=\"line\">void addReplyBulk(redisClient *c, robj *obj) &#123;</span><br><span class=\"line\">    addReplyBulkLen(c,obj);</span><br><span class=\"line\">    addReply(c,obj);</span><br><span class=\"line\">    addReply(c,shared.crlf);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会直接将robj对象作为返回参数</p>\n<p>并且客户端传入参数也是一个个robj对象，会直接作为值保存到对象中</p>\n<h3 id=\"共享时如何删除\"><a href=\"#共享时如何删除\" class=\"headerlink\" title=\"共享时如何删除\"></a>共享时如何删除</h3><p>那么，共享对象在单线程情况下是如何删除的呢？</p>\n<p>看看del命令的实现</p>\n<p>del调用dictDelete，最终调用每个数据类型自己的析构函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dictFreeKey(d, he);</span><br><span class=\"line\">dictFreeVal(d, he);</span><br></pre></td></tr></table></figure>\n<p>集合类型调用如下函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void dictRedisObjectDestructor(void *privdata, void *val)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DICT_NOTUSED(privdata);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (val == NULL) return; /* Values of swapped out keys as set to NULL */</span><br><span class=\"line\">    decrRefCount(val);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，只是将值的refcount减1<br>如何解决共享数据<br>新版本如何解决了共享数据</p>\n<p>还是通过sunionstore和smembers命令看下这两处如何解决共享：</p>\n<p>以下代码使用redis 5.0.3版本介绍：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void saddCommand(client *c) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    for (j = 2; j &lt; c-&gt;argc; j++) &#123;</span><br><span class=\"line\">        if (setTypeAdd(set,c-&gt;argv[j]-&gt;ptr)) added++; //sadd的时候元素也变为了c-&gt;argv[j]-&gt;ptr,一个字符串</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">int setTypeAdd(robj *subject, sds value) &#123;//value是一个sds</span><br><span class=\"line\">    long long llval;</span><br><span class=\"line\">    if (subject-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class=\"line\">        dict *ht = subject-&gt;ptr;</span><br><span class=\"line\">        dictEntry *de = dictAddRaw(ht,value,NULL);</span><br><span class=\"line\">        if (de) &#123;</span><br><span class=\"line\">            dictSetKey(ht,de,sdsdup(value));</span><br><span class=\"line\">            dictSetVal(ht,de,NULL);</span><br><span class=\"line\">            return 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>增加值的时候已经变为了一个sds.</p>\n<p>现在的保存结构为：</p>\n<pre><code>key -&gt; value_obj -&gt; hash table -&gt; sds_string\n</code></pre><p>而返回到客户端的时候也变为了一个sds,如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">addReplyBulkCBuffer(c,elesds,sdslen(elesds));</span><br><span class=\"line\"></span><br><span class=\"line\">void addReplyBulkCBuffer(client *c, const void *p, size_t len) &#123;</span><br><span class=\"line\">    addReplyLongLongWithPrefix(c,len,&apos;$&apos;);</span><br><span class=\"line\">    addReplyString(c,p,len);</span><br><span class=\"line\">    addReply(c,shared.crlf);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"效果如何\"><a href=\"#效果如何\" class=\"headerlink\" title=\"效果如何\"></a>效果如何</h3><p>效果如何呢？</p>\n<p>首先取值的时候从robj的间接引用变为了一个sds的直接引用。</p>\n<p>其次减少了共享会增加内存的消耗，而使用了sds之后，每个sds的内存占用会比一个robj要小。我们看下antirez如何评价这个修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">The result is that Redis is now more memory efficient since there are no robj structures around in the implementation of the data structures (but they are used in the code paths where there is a lot of sharing going on, for example during the command dispatch and replication). </span><br><span class=\"line\">...</span><br><span class=\"line\">But, the most interesting thing is, Redis is now faster in all the operations I tested so far. Less indirection was a real winner here. It is faster even in unrelated benchmarks just because the client output buffers are now simpler and faster.</span><br></pre></td></tr></table></figure>\n<p>说了两层意思，一是内存使用更加高效了</p>\n<p>二是更少的间接引用导致redis比以前更加快，而且客户端输出更加简洁和快速。</p>\n<h2 id=\"异步线程-1\"><a href=\"#异步线程-1\" class=\"headerlink\" title=\"异步线程\"></a>异步线程</h2><p>异步线程的实现以后在详细描述</p>\n<p>问题</p>\n<p>1.多线程之间在堆上分配内存时会有争用。但是antirez说因为redis在内存分配上使用的时间极少，可以忽略这种情况。</p>\n<p>如何考虑这个问题？</p>\n<p>参考：<a href=\"https://software.intel.com/zh-cn/articles/avoiding-heap-contention-among-threads\" target=\"_blank\" rel=\"noopener\">https://software.intel.com/zh-cn/articles/avoiding-heap-contention-among-threads</a></p>\n"},{"title":"Redis有序集合指令学习","date":"2018-07-11T05:21:01.000Z","_content":"## ZADD\nZADD key [NX|XX] [CH] [INCR]score member [score member ...]\n\n将元素及对应分值添加到一个有序集合中\n\nNX:不更新已经存在的key,只增加新元素\n\nXX:只更新已经存在的key,不增加新元素\n\nCH:abbr:changed.不指定时只返回新增的元素个数,指定时返回新增的和更新的元素个数之和\n\nINCR:参考zincrby\n\n```c\n//通过第二个参数区分是zadd还是zincrby\nvoid zaddCommand(client *c) {\n    zaddGenericCommand(c,ZADD_NONE);\n}\n```\n\n```c\n/* This generic command implements both ZADD and ZINCRBY. */\n//zadd和zincrby两个命令都是调用这个函数\nvoid zaddGenericCommand(client *c, int flags) {\n    static char *nanerr = \"resulting score is not a number (NaN)\";\n    robj *key = c->argv[1];\n    robj *zobj;\n    sds ele;\n    double score = 0, *scores = NULL;\n    int j, elements;\n    int scoreidx = 0;\n    /* The following vars are used in order to track what the command actually\n     * did during the execution, to reply to the client and to trigger the\n     * notification of keyspace change. */\n    int added = 0;      /* Number of new elements added. */\n    int updated = 0;    /* Number of elements with updated score. */\n    int processed = 0;  /* Number of elements processed, may remain zero with\n                           options like XX. */\n\n    /* Parse options. At the end 'scoreidx' is set to the argument position\n     * of the score of the first score-element pair. */\n    scoreidx = 2;//从第二个参数开始处理.先处理nx,xx,ch,incr参数\n    while(scoreidx < c->argc) {\n        char *opt = c->argv[scoreidx]->ptr;\n        if (!strcasecmp(opt,\"nx\")) flags |= ZADD_NX;\n        else if (!strcasecmp(opt,\"xx\")) flags |= ZADD_XX;\n        else if (!strcasecmp(opt,\"ch\")) flags |= ZADD_CH;\n        else if (!strcasecmp(opt,\"incr\")) flags |= ZADD_INCR;\n        else break;\n        scoreidx++;\n    }\n\n    /* Turn options into simple to check vars. */\n    //从flag中取出相应的标志赋给独立的变量\n    int incr = (flags & ZADD_INCR) != 0;\n    int nx = (flags & ZADD_NX) != 0;\n    int xx = (flags & ZADD_XX) != 0;\n    int ch = (flags & ZADD_CH) != 0;\n\n    /* After the options, we expect to have an even number of args, since\n     * we expect any number of score-element pairs. */\n    //member和score是一一对应的,所以肯定是2的倍数.所以如果不是2的倍数或者根本\n    //没有member和score,直接返回命令语法错误\n    elements = c->argc-scoreidx;\n    if (elements % 2 || !elements) {\n        addReply(c,shared.syntaxerr);\n        return;\n    }\n    //elements赋值为有多少对<element,score>\n    elements /= 2; /* Now this holds the number of score-element pairs. */\n\n    /* Check for incompatible options. */\n    //nx和xxflag互斥,二者不能同时出现\n    if (nx && xx) {\n        addReplyError(c,\n            \"XX and NX options at the same time are not compatible\");\n        return;\n    }\n    //若有incr标志,则只能有一对<element,score>\n    //为什么不能是多对?\n    if (incr && elements > 1) {\n        addReplyError(c,\n            \"INCR option supports a single increment-element pair\");\n        return;\n    }\n\n    /* Start parsing all the scores, we need to emit any syntax error\n     * before executing additions to the sorted set, as the command should\n     * either execute fully or nothing at all. */\n    //依次检查每一个分数值\n    scores = zmalloc(sizeof(double)*elements);\n    for (j = 0; j < elements; j++) {\n        //该函数中会检查score是否是合法的double类型的值\n        if (getDoubleFromObjectOrReply(c,c->argv[scoreidx+j*2],&scores[j],NULL)\n            != C_OK) goto cleanup;\n    }\n\n    /* Lookup the key and create the sorted set if does not exist. */\n    //根据key查找对应的有序集合的value\n    zobj = lookupKeyWrite(c->db,key);\n    //key不存在\n    if (zobj == NULL) {\n        //如果设置了xx这个flag,直接返回错误\n        if (xx) goto reply_to_client; /* No key + XX option: nothing to do. */\n        //根据redis的配置,如果有序集合设置了不使用ziplist存储或者说第一个插入元素的长度大于\n        //设置的最大ziplist的元素长度值,则使用跳跃表存储否则使用ziplist\n        if (server.zset_max_ziplist_entries == 0 ||\n            server.zset_max_ziplist_value < sdslen(c->argv[scoreidx+1]->ptr))\n        {\n            zobj = createZsetObject();\n        } else {\n            zobj = createZsetZiplistObject();\n        }\n        //把key,zobj插入字典\n        dbAdd(c->db,key,zobj);\n    //key存在\n    } else {\n        //如果不是有序集合,直接返回错误\n        if (zobj->type != OBJ_ZSET) {\n            addReply(c,shared.wrongtypeerr);\n            goto cleanup;\n        }\n    }\n\n    //elements是<member,score>对数\n    for (j = 0; j < elements; j++) {\n        double newscore;\n        score = scores[j];\n        //retflags设置为前文中的flags变量\n        int retflags = flags;\n\n        ele = c->argv[scoreidx+1+j*2]->ptr;\n        //每次遍历,score是分数,ele是member.调用zsetadd插入zobj\n        int retval = zsetAdd(zobj, score, ele, &retflags, &newscore);\n        if (retval == 0) {\n            addReplyError(c,nanerr);\n            goto cleanup;\n        }\n        //根据retflags,即一个元素是更新还是新加入,还是未做处理(即member存在,并且\n        //score值与新设置的一致),更新相应的计数变量(这些变量最后会返回给客户端)\n        if (retflags & ZADD_ADDED) added++;\n        if (retflags & ZADD_UPDATED) updated++;\n        if (!(retflags & ZADD_NOP)) processed++;\n        score = newscore;\n    }\n    server.dirty += (added+updated);\n//通过命令中的flag,返回给客户端不同的值\nreply_to_client:\n    if (incr) { /* ZINCRBY or INCR option. */\n        if (processed)\n            addReplyDouble(c,score);\n        else\n            addReply(c,shared.nullbulk);\n    } else { /* ZADD. */\n        addReplyLongLong(c,ch ? added+updated : added);\n    }\n\n//如果有更新或者新加,需要执行相应的watch key的通知及keyspace的通知\ncleanup:\n    zfree(scores);\n    if (added || updated) {\n        signalModifiedKey(c->db,key);\n        notifyKeyspaceEvent(NOTIFY_ZSET,\n            incr ? \"zincr\" : \"zadd\", key, c->db->id);\n    }\n}\n```\n\n## ZINCRBY \n\nZINCRBY key increment member\n\n如果key存在,就给相应member的score增加increment\n\n否则直接给key设置分数为increment\n\n```c\n\n//与zadd调用同一个函数,相当于zadd key incr,把incr flag置位\nvoid zincrbyCommand(client *c) {\n    zaddGenericCommand(c,ZADD_INCR);\n}\n```\n\n## ZCARD\nZCARD key\n\n返回有序集合的元素个数\n```c\nvoid zcardCommand(client *c) {\n    robj *key = c->argv[1];\n    robj *zobj;\n    //查找key对应的value\n    if ((zobj = lookupKeyReadOrReply(c,key,shared.czero)) == NULL ||\n        checkType(c,zobj,OBJ_ZSET)) return;\n    //通过zsetLength获取zobj中的元素个数\n    addReplyLongLong(c,zsetLength(zobj));\n}\n```\n\n```c\nunsigned int zsetLength(const robj *zobj) {\n    int length = -1;\n    //如果是ziplist,通过zzlLength函数获取长度\n    //如果长度字段中的值小于UINT16_MAX，直接返回长度。否则需要遍历获取长度\n    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {\n        length = zzlLength(zobj->ptr);\n    //如果是skiplist,直接返回zsl->length\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        length = ((const zset*)zobj->ptr)->zsl->length;\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n    return length;\n}\n```\n\n## ZCOUNT\nZCOUNT key min max\n\n返回key中score值在min和max之间的元素个数\n\n其中min和max可以加(,如 zcount key (5 (10 \n\n加左括号表示不包含。不加表示包含\n\n```c\nvoid zcountCommand(client *c) {\n    robj *key = c->argv[1];\n    robj *zobj;\n    zrangespec range;\n    int count = 0;\n\n    /* Parse the range arguments */\n    //判定范围.并将最大最小及是否包含写入range结构体中\n    if (zslParseRange(c->argv[2],c->argv[3],&range) != C_OK) {\n        addReplyError(c,\"min or max is not a float\");\n        return;\n    }\n\n    /* Lookup the sorted set */\n    if ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == NULL ||\n        checkType(c, zobj, OBJ_ZSET)) return;\n    //判断zobj底层编码是ziplist还是skiplist\n    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {\n        unsigned char *zl = zobj->ptr;\n        unsigned char *eptr, *sptr;\n        double score;\n        //找出第一个在范围之内的元素\n        /* Use the first element in range as the starting point */\n        eptr = zzlFirstInRange(zl,&range);\n\n        /* No \"first\" element */\n        if (eptr == NULL) {\n            addReply(c, shared.czero);\n            return;\n        }\n\n        /* First element is in range */\n        //ziplist中member和score是两个entry,并且member之后保存着score\n        //整体顺序是按score从小到大排列,score相同时,按member的字典序排列\n        sptr = ziplistNext(zl,eptr);\n        //所以此处从第一个元素的下一个entry处获取score\n        score = zzlGetScore(sptr);\n        serverAssertWithInfo(c,zobj,zslValueLteMax(score,&range));\n\n        /* Iterate over elements in range */\n        //迭代这个ziplist,如果score满足要求,则count++并且继续迭代,否则跳出\n        //最后会返回count\n        while (eptr) {\n            score = zzlGetScore(sptr);\n\n            /* Abort when the node is no longer in range. */\n            if (!zslValueLteMax(score,&range)) {\n                break;\n            } else {\n                count++;\n                zzlNext(zl,&eptr,&sptr);\n            }\n        }\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        zskiplist *zsl = zs->zsl;\n        zskiplistNode *zn;\n        unsigned long rank;\n        //如果是跳表,也是先取出第一个元素\n        /* Find first element in range */\n        zn = zslFirstInRange(zsl, &range);\n\n        /* Use rank of first element, if any, to determine preliminary count */\n        if (zn != NULL) {\n            //获取第一个元素的排名\n            rank = zslGetRank(zsl, zn->score, zn->ele);\n            count = (zsl->length - (rank - 1));\n            //如果最大值大于zsl中的最大值,则此count就是要找的个数\n            /* Find last element in range */\n            zn = zslLastInRange(zsl, &range);\n\n            /* Use rank of last element, if any, to determine the actual count */\n            if (zn != NULL) {\n                //如果最大值小于zsl中的最大值，则首先找到最后一个元素的rank\n                rank = zslGetRank(zsl, zn->score, zn->ele);\n                //重新计算count,与之前的计算公式合并之后为\n                //count = (zsl->length-(rankmin-1))-(zsl->length-rankmax))\n                //      = rankmax-rankmin+1\n                count -= (zsl->length - rank);\n            }\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n    //返回count\n    addReplyLongLong(c, count);\n}\n```\n\n## ZRANGEBYSCORE\nZRANGEBYSCORE key min max [WITHSCORES][LIMIT offset count]\n\n获取有序结合中分值位于 min和max之间的所有元素\n\nwithscores:将member 和 score一起返回 \n\nlimit offset count:从偏移offset开始获取count个元素\n\nmin和max可以为 -inf,+inf,分别表示负无穷和正无穷\n\n```c\n\n//入口函数\nvoid zrangebyscoreCommand(client *c) {\n    genericZrangebyscoreCommand(c,0);\n}\n\n```\n\n```c\n/* This command implements ZRANGEBYSCORE, ZREVRANGEBYSCORE. */\nvoid genericZrangebyscoreCommand(client *c, int reverse) {\n    zrangespec range;\n    robj *key = c->argv[1];\n    robj *zobj;\n    long offset = 0, limit = -1;\n    int withscores = 0;\n    unsigned long rangelen = 0;\n    void *replylen = NULL;\n    int minidx, maxidx;\n    //该函数同时用于zrangbyscore和zrevrangebyscore\n    //二者通过函数中的reverse参数标识\n    //正序时第二个参数是min，第三个参数是max,逆序反之\n    /* Parse the range arguments. */\n    if (reverse) {\n        /* Range is given as [max,min] */\n        maxidx = 2; minidx = 3;\n    } else {\n        /* Range is given as [min,max] */\n        minidx = 2; maxidx = 3;\n    }\n    //将参数解析出来赋值到range变量\n    if (zslParseRange(c->argv[minidx],c->argv[maxidx],&range) != C_OK) {\n        addReplyError(c,\"min or max is not a float\");\n        return;\n    }\n\n    /* Parse optional extra arguments. Note that ZCOUNT will exactly have\n     * 4 arguments, so we'll never enter the following code path. */\n    if (c->argc > 4) {\n        int remaining = c->argc - 4;\n        int pos = 4;\n        //解析withscores和limit参数\n        while (remaining) {\n            if (remaining >= 1 && !strcasecmp(c->argv[pos]->ptr,\"withscores\")) {\n                pos++; remaining--;\n                withscores = 1;\n            } else if (remaining >= 3 && !strcasecmp(c->argv[pos]->ptr,\"limit\")) {\n                if ((getLongFromObjectOrReply(c, c->argv[pos+1], &offset, NULL)\n                        != C_OK) ||\n                    (getLongFromObjectOrReply(c, c->argv[pos+2], &limit, NULL)\n                        != C_OK))\n                {\n                    return;\n                }\n                pos += 3; remaining -= 3;\n            } else {\n                addReply(c,shared.syntaxerr);\n                return;\n            }\n        }\n    }\n\n    /* Ok, lookup the key and get the range */\n    if ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == NULL ||\n        checkType(c,zobj,OBJ_ZSET)) return;\n    //按zset底层编码是ziplist还是skiplist分别处理\n    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {\n        unsigned char *zl = zobj->ptr;\n        unsigned char *eptr, *sptr;\n        unsigned char *vstr;\n        unsigned int vlen;\n        long long vlong;\n        double score;\n\n        /* If reversed, get the last node in range as starting point. */\n        //按正序还是逆序分别取最后一个值或者第一个值\n        if (reverse) {\n            eptr = zzlLastInRange(zl,&range);\n        } else {\n            eptr = zzlFirstInRange(zl,&range);\n        }\n\n        /* No \"first\" element in the specified interval. */\n        if (eptr == NULL) {\n            addReply(c, shared.emptymultibulk);\n            return;\n        }\n\n        /* Get score pointer for the first element. */\n        serverAssertWithInfo(c,zobj,eptr != NULL);\n        sptr = ziplistNext(zl,eptr);\n\n        /* We don't know in advance how many matching elements there are in the\n         * list, so we push this object that will represent the multi-bulk\n         * length in the output buffer, and will \"fix\" it later */\n        replylen = addDeferredMultiBulkLength(c);\n\n        /* If there is an offset, just traverse the number of elements without\n         * checking the score because that is done in the next loop. */\n        //如果有offset,先偏移相应的元素\n        //注意此处zzlNext传入了两个指针,会一次偏移一个<member,score>对\n        //注意此处offset初始值是0,如果没指定则不会进入此处循环\n        while (eptr && offset--) {\n            if (reverse) {\n                zzlPrev(zl,&eptr,&sptr);\n            } else {\n                zzlNext(zl,&eptr,&sptr);\n            }\n        }\n\n        //如果有limit,则进入循环.取limit次.limit的初始值为-1,即使没指定,也会进入循环\n        //直到eptr为null或者循环中break掉\n        while (eptr && limit--) {\n            score = zzlGetScore(sptr);\n\n            /* Abort when the node is no longer in range. */\n            //不在范围之内时break掉\n            if (reverse) {\n                if (!zslValueGteMin(score,&range)) break;\n            } else {\n                if (!zslValueLteMax(score,&range)) break;\n            }\n\n            /* We know the element exists, so ziplistGet should always succeed */\n            serverAssertWithInfo(c,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));\n            //取出相应的值.可能为str,赋值给vstr,长度为vlen,或者为整型,赋值给vlong\n            rangelen++;\n            if (vstr == NULL) {\n                addReplyBulkLongLong(c,vlong);\n            } else {\n                addReplyBulkCBuffer(c,vstr,vlen);\n            }\n            //如果设置了withscores标志,则返回分数\n            if (withscores) {\n                addReplyDouble(c,score);\n            }\n            //开始迭代下一个节点\n            /* Move to next node */\n            if (reverse) {\n                zzlPrev(zl,&eptr,&sptr);\n            } else {\n                zzlNext(zl,&eptr,&sptr);\n            }\n        }\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        zskiplist *zsl = zs->zsl;\n        zskiplistNode *ln;\n\n        //同ziplist,先查找起始或最终节点\n        /* If reversed, get the last node in range as starting point. */\n        if (reverse) {\n            ln = zslLastInRange(zsl,&range);\n        } else {\n            ln = zslFirstInRange(zsl,&range);\n        }\n\n        /* No \"first\" element in the specified interval. */\n        if (ln == NULL) {\n            addReply(c, shared.emptymultibulk);\n            return;\n        }\n\n        /* We don't know in advance how many matching elements there are in the\n         * list, so we push this object that will represent the multi-bulk\n         * length in the output buffer, and will \"fix\" it later */\n        //返回客户端时先返回元素个数,但此处并不知道需要返回多少个元素,所以先占个位置\n        //replylen是存储len字段的指针\n        replylen = addDeferredMultiBulkLength(c);\n\n        /* If there is an offset, just traverse the number of elements without\n         * checking the score because that is done in the next loop. */\n        //处理offset.向前或向后skip\n        while (ln && offset--) {\n            if (reverse) {\n                ln = ln->backward;\n            } else {\n                ln = ln->level[0].forward;\n            }\n        }\n\n        //处理limit\n        while (ln && limit--) {\n            /* Abort when the node is no longer in range. */\n            if (reverse) {\n                if (!zslValueGteMin(ln->score,&range)) break;\n            } else {\n                if (!zslValueLteMax(ln->score,&range)) break;\n            }\n\n            rangelen++;\n            addReplyBulkCBuffer(c,ln->ele,sdslen(ln->ele));\n\n            if (withscores) {\n                addReplyDouble(c,ln->score);\n            }\n\n            /* Move to next node */\n            if (reverse) {\n                ln = ln->backward;\n            } else {\n                ln = ln->level[0].forward;\n            }\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n    //如果有withscores参数,返回给客户端的字符串数量是2倍\n    if (withscores) {\n        rangelen *= 2;\n    }\n    //将rangelen放入replylen指向的位置,返回给客户端\n    setDeferredMultiBulkLength(c, replylen, rangelen);\n}\n```\n\n## ZRANK\nZRANK key member\n\n返回有序集合中元素member的rank\n\n以0为起始rank,元素分数从低到高\n\nzrevrank,元素分数从高到低\n\n```c\nvoid zrankGenericCommand(client *c, int reverse) {\n    robj *key = c->argv[1];\n    robj *ele = c->argv[2];\n    robj *zobj;\n    long rank;\n    //通过key找出有序集合的value zobj\n    if ((zobj = lookupKeyReadOrReply(c,key,shared.nullbulk)) == NULL ||\n        checkType(c,zobj,OBJ_ZSET)) return;\n\n    serverAssertWithInfo(c,ele,sdsEncodedObject(ele));\n    //在zobj中查找ele(第二个参数member)\n    rank = zsetRank(zobj,ele->ptr,reverse);\n    if (rank >= 0) {\n        addReplyLongLong(c,rank);\n    } else {\n        addReply(c,shared.nullbulk);\n    }\n}\n\nvoid zrankCommand(client *c) {\n    zrankGenericCommand(c, 0);\n}\n```\n```c\nlong zsetRank(robj *zobj, sds ele, int reverse) {\n    unsigned long llen;\n    unsigned long rank;\n\n    llen = zsetLength(zobj);\n    //ziplist从前往后遍历,比较entry中的元素与ele,每次将rank++\n    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {\n        unsigned char *zl = zobj->ptr;\n        unsigned char *eptr, *sptr;\n\n        eptr = ziplistIndex(zl,0);\n        serverAssert(eptr != NULL);\n        sptr = ziplistNext(zl,eptr);\n        serverAssert(sptr != NULL);\n\n        rank = 1;\n        while(eptr != NULL) {\n            if (ziplistCompare(eptr,(unsigned char*)ele,sdslen(ele)))\n                break;\n            rank++;\n            zzlNext(zl,&eptr,&sptr);\n        }\n\n        if (eptr != NULL) {\n            //如果是逆序取,直接将llen-rank就是逆向的rank\n            if (reverse)\n                return llen-rank;\n            else\n                return rank-1;\n        } else {\n            return -1;\n        }\n    //skiplist通过zslGetRank获取rank,具体过程为跳表查找,将相应路过节点的span相加\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        zskiplist *zsl = zs->zsl;\n        dictEntry *de;\n        double score;\n\n        de = dictFind(zs->dict,ele);\n        if (de != NULL) {\n            score = *(double*)dictGetVal(de);\n            rank = zslGetRank(zsl,score,ele);\n            /* Existing elements always have a rank. */\n            serverAssert(rank != 0);\n            //逆向取rank\n            if (reverse)\n                return llen-rank;\n            else\n                return rank-1;\n        } else {\n            return -1;\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n}\n```\n\n## ZREM\nZREM key member [member ...]\n\n从有序集合中删除相应的member\n\n\n```c\nvoid zremCommand(client *c) {\n    robj *key = c->argv[1];\n    robj *zobj;\n    int deleted = 0, keyremoved = 0, j;\n    //根据key找到对应的zobj\n    if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||\n        checkType(c,zobj,OBJ_ZSET)) return;\n    //依次删除相应的元素,每次删除之后检查zset是否为空,如果为空,删掉该key,并且break\n    for (j = 2; j < c->argc; j++) {\n        if (zsetDel(zobj,c->argv[j]->ptr)) deleted++;\n        if (zsetLength(zobj) == 0) {\n            dbDelete(c->db,key);\n            keyremoved = 1;\n            break;\n        }\n    }\n    //如果确实有member被删除掉,通知keyspace zrem事件\n    //如果zset整个都被删除了,通知keyspace del事件\n    if (deleted) {\n        notifyKeyspaceEvent(NOTIFY_ZSET,\"zrem\",key,c->db->id);\n        if (keyremoved)\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",key,c->db->id);\n        signalModifiedKey(c->db,key);\n        server.dirty += deleted;\n    }\n    //返回给客户端实际删除的member个数\n    addReplyLongLong(c,deleted);\n}\n```\n\n```c\n/* Delete the element 'ele' from the sorted set, returning 1 if the element\n * existed and was deleted, 0 otherwise (the element was not there). */\nint zsetDel(robj *zobj, sds ele) {\n    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {\n        unsigned char *eptr;\n        //ziplist先找到ele所在位置的指针eptr\n        if ((eptr = zzlFind(zobj->ptr,ele,NULL)) != NULL) {\n            //将该元素删除.ziplist删除时会resize,此处将删除之后ziplist的指针复值给zobj->ptr\n            zobj->ptr = zzlDelete(zobj->ptr,eptr);\n            return 1;\n        }\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        dictEntry *de;\n        double score;\n        //skiplist现将zobj->ptr->dict相应的ele删除掉。此处并未真实删除\n        //而是将ele所在的dictEntry返回\n        de = dictUnlink(zs->dict,ele);\n        if (de != NULL) {\n            /* Get the score in order to delete from the skiplist later. */\n            //通过dictEntry获取score\n            score = *(double*)dictGetVal(de);\n\n            /* Delete from the hash table and later from the skiplist.\n             * Note that the order is important: deleting from the skiplist\n             * actually releases the SDS string representing the element,\n             * which is shared between the skiplist and the hash table, so\n             * we need to delete from the skiplist as the final step. */\n            //此处将dict中的key和value实际free掉\n            dictFreeUnlinkedEntry(zs->dict,de);\n\n            /* Delete from skiplist. */\n            //从skiplist中删除元素.ele这个sds在hash和skiplist共享.从skiplist中删除时\n            //会释放此sds,所以必须先删除dict中的元素再删除skiplist中的元素\n            int retval = zslDelete(zs->zsl,score,ele,NULL);\n            serverAssert(retval);\n            //如果hash表中元素使用率小于10%,进行dict的resize\n            if (htNeedsResize(zs->dict)) dictResize(zs->dict);\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n    return 0; /* No such element found. */\n}\n```","source":"_posts/Redis有序集合指令学习.md","raw":"---\ntitle: Redis有序集合指令学习\ndate: 2018-07-11 13:21:01\ntags:\n---\n## ZADD\nZADD key [NX|XX] [CH] [INCR]score member [score member ...]\n\n将元素及对应分值添加到一个有序集合中\n\nNX:不更新已经存在的key,只增加新元素\n\nXX:只更新已经存在的key,不增加新元素\n\nCH:abbr:changed.不指定时只返回新增的元素个数,指定时返回新增的和更新的元素个数之和\n\nINCR:参考zincrby\n\n```c\n//通过第二个参数区分是zadd还是zincrby\nvoid zaddCommand(client *c) {\n    zaddGenericCommand(c,ZADD_NONE);\n}\n```\n\n```c\n/* This generic command implements both ZADD and ZINCRBY. */\n//zadd和zincrby两个命令都是调用这个函数\nvoid zaddGenericCommand(client *c, int flags) {\n    static char *nanerr = \"resulting score is not a number (NaN)\";\n    robj *key = c->argv[1];\n    robj *zobj;\n    sds ele;\n    double score = 0, *scores = NULL;\n    int j, elements;\n    int scoreidx = 0;\n    /* The following vars are used in order to track what the command actually\n     * did during the execution, to reply to the client and to trigger the\n     * notification of keyspace change. */\n    int added = 0;      /* Number of new elements added. */\n    int updated = 0;    /* Number of elements with updated score. */\n    int processed = 0;  /* Number of elements processed, may remain zero with\n                           options like XX. */\n\n    /* Parse options. At the end 'scoreidx' is set to the argument position\n     * of the score of the first score-element pair. */\n    scoreidx = 2;//从第二个参数开始处理.先处理nx,xx,ch,incr参数\n    while(scoreidx < c->argc) {\n        char *opt = c->argv[scoreidx]->ptr;\n        if (!strcasecmp(opt,\"nx\")) flags |= ZADD_NX;\n        else if (!strcasecmp(opt,\"xx\")) flags |= ZADD_XX;\n        else if (!strcasecmp(opt,\"ch\")) flags |= ZADD_CH;\n        else if (!strcasecmp(opt,\"incr\")) flags |= ZADD_INCR;\n        else break;\n        scoreidx++;\n    }\n\n    /* Turn options into simple to check vars. */\n    //从flag中取出相应的标志赋给独立的变量\n    int incr = (flags & ZADD_INCR) != 0;\n    int nx = (flags & ZADD_NX) != 0;\n    int xx = (flags & ZADD_XX) != 0;\n    int ch = (flags & ZADD_CH) != 0;\n\n    /* After the options, we expect to have an even number of args, since\n     * we expect any number of score-element pairs. */\n    //member和score是一一对应的,所以肯定是2的倍数.所以如果不是2的倍数或者根本\n    //没有member和score,直接返回命令语法错误\n    elements = c->argc-scoreidx;\n    if (elements % 2 || !elements) {\n        addReply(c,shared.syntaxerr);\n        return;\n    }\n    //elements赋值为有多少对<element,score>\n    elements /= 2; /* Now this holds the number of score-element pairs. */\n\n    /* Check for incompatible options. */\n    //nx和xxflag互斥,二者不能同时出现\n    if (nx && xx) {\n        addReplyError(c,\n            \"XX and NX options at the same time are not compatible\");\n        return;\n    }\n    //若有incr标志,则只能有一对<element,score>\n    //为什么不能是多对?\n    if (incr && elements > 1) {\n        addReplyError(c,\n            \"INCR option supports a single increment-element pair\");\n        return;\n    }\n\n    /* Start parsing all the scores, we need to emit any syntax error\n     * before executing additions to the sorted set, as the command should\n     * either execute fully or nothing at all. */\n    //依次检查每一个分数值\n    scores = zmalloc(sizeof(double)*elements);\n    for (j = 0; j < elements; j++) {\n        //该函数中会检查score是否是合法的double类型的值\n        if (getDoubleFromObjectOrReply(c,c->argv[scoreidx+j*2],&scores[j],NULL)\n            != C_OK) goto cleanup;\n    }\n\n    /* Lookup the key and create the sorted set if does not exist. */\n    //根据key查找对应的有序集合的value\n    zobj = lookupKeyWrite(c->db,key);\n    //key不存在\n    if (zobj == NULL) {\n        //如果设置了xx这个flag,直接返回错误\n        if (xx) goto reply_to_client; /* No key + XX option: nothing to do. */\n        //根据redis的配置,如果有序集合设置了不使用ziplist存储或者说第一个插入元素的长度大于\n        //设置的最大ziplist的元素长度值,则使用跳跃表存储否则使用ziplist\n        if (server.zset_max_ziplist_entries == 0 ||\n            server.zset_max_ziplist_value < sdslen(c->argv[scoreidx+1]->ptr))\n        {\n            zobj = createZsetObject();\n        } else {\n            zobj = createZsetZiplistObject();\n        }\n        //把key,zobj插入字典\n        dbAdd(c->db,key,zobj);\n    //key存在\n    } else {\n        //如果不是有序集合,直接返回错误\n        if (zobj->type != OBJ_ZSET) {\n            addReply(c,shared.wrongtypeerr);\n            goto cleanup;\n        }\n    }\n\n    //elements是<member,score>对数\n    for (j = 0; j < elements; j++) {\n        double newscore;\n        score = scores[j];\n        //retflags设置为前文中的flags变量\n        int retflags = flags;\n\n        ele = c->argv[scoreidx+1+j*2]->ptr;\n        //每次遍历,score是分数,ele是member.调用zsetadd插入zobj\n        int retval = zsetAdd(zobj, score, ele, &retflags, &newscore);\n        if (retval == 0) {\n            addReplyError(c,nanerr);\n            goto cleanup;\n        }\n        //根据retflags,即一个元素是更新还是新加入,还是未做处理(即member存在,并且\n        //score值与新设置的一致),更新相应的计数变量(这些变量最后会返回给客户端)\n        if (retflags & ZADD_ADDED) added++;\n        if (retflags & ZADD_UPDATED) updated++;\n        if (!(retflags & ZADD_NOP)) processed++;\n        score = newscore;\n    }\n    server.dirty += (added+updated);\n//通过命令中的flag,返回给客户端不同的值\nreply_to_client:\n    if (incr) { /* ZINCRBY or INCR option. */\n        if (processed)\n            addReplyDouble(c,score);\n        else\n            addReply(c,shared.nullbulk);\n    } else { /* ZADD. */\n        addReplyLongLong(c,ch ? added+updated : added);\n    }\n\n//如果有更新或者新加,需要执行相应的watch key的通知及keyspace的通知\ncleanup:\n    zfree(scores);\n    if (added || updated) {\n        signalModifiedKey(c->db,key);\n        notifyKeyspaceEvent(NOTIFY_ZSET,\n            incr ? \"zincr\" : \"zadd\", key, c->db->id);\n    }\n}\n```\n\n## ZINCRBY \n\nZINCRBY key increment member\n\n如果key存在,就给相应member的score增加increment\n\n否则直接给key设置分数为increment\n\n```c\n\n//与zadd调用同一个函数,相当于zadd key incr,把incr flag置位\nvoid zincrbyCommand(client *c) {\n    zaddGenericCommand(c,ZADD_INCR);\n}\n```\n\n## ZCARD\nZCARD key\n\n返回有序集合的元素个数\n```c\nvoid zcardCommand(client *c) {\n    robj *key = c->argv[1];\n    robj *zobj;\n    //查找key对应的value\n    if ((zobj = lookupKeyReadOrReply(c,key,shared.czero)) == NULL ||\n        checkType(c,zobj,OBJ_ZSET)) return;\n    //通过zsetLength获取zobj中的元素个数\n    addReplyLongLong(c,zsetLength(zobj));\n}\n```\n\n```c\nunsigned int zsetLength(const robj *zobj) {\n    int length = -1;\n    //如果是ziplist,通过zzlLength函数获取长度\n    //如果长度字段中的值小于UINT16_MAX，直接返回长度。否则需要遍历获取长度\n    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {\n        length = zzlLength(zobj->ptr);\n    //如果是skiplist,直接返回zsl->length\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        length = ((const zset*)zobj->ptr)->zsl->length;\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n    return length;\n}\n```\n\n## ZCOUNT\nZCOUNT key min max\n\n返回key中score值在min和max之间的元素个数\n\n其中min和max可以加(,如 zcount key (5 (10 \n\n加左括号表示不包含。不加表示包含\n\n```c\nvoid zcountCommand(client *c) {\n    robj *key = c->argv[1];\n    robj *zobj;\n    zrangespec range;\n    int count = 0;\n\n    /* Parse the range arguments */\n    //判定范围.并将最大最小及是否包含写入range结构体中\n    if (zslParseRange(c->argv[2],c->argv[3],&range) != C_OK) {\n        addReplyError(c,\"min or max is not a float\");\n        return;\n    }\n\n    /* Lookup the sorted set */\n    if ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == NULL ||\n        checkType(c, zobj, OBJ_ZSET)) return;\n    //判断zobj底层编码是ziplist还是skiplist\n    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {\n        unsigned char *zl = zobj->ptr;\n        unsigned char *eptr, *sptr;\n        double score;\n        //找出第一个在范围之内的元素\n        /* Use the first element in range as the starting point */\n        eptr = zzlFirstInRange(zl,&range);\n\n        /* No \"first\" element */\n        if (eptr == NULL) {\n            addReply(c, shared.czero);\n            return;\n        }\n\n        /* First element is in range */\n        //ziplist中member和score是两个entry,并且member之后保存着score\n        //整体顺序是按score从小到大排列,score相同时,按member的字典序排列\n        sptr = ziplistNext(zl,eptr);\n        //所以此处从第一个元素的下一个entry处获取score\n        score = zzlGetScore(sptr);\n        serverAssertWithInfo(c,zobj,zslValueLteMax(score,&range));\n\n        /* Iterate over elements in range */\n        //迭代这个ziplist,如果score满足要求,则count++并且继续迭代,否则跳出\n        //最后会返回count\n        while (eptr) {\n            score = zzlGetScore(sptr);\n\n            /* Abort when the node is no longer in range. */\n            if (!zslValueLteMax(score,&range)) {\n                break;\n            } else {\n                count++;\n                zzlNext(zl,&eptr,&sptr);\n            }\n        }\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        zskiplist *zsl = zs->zsl;\n        zskiplistNode *zn;\n        unsigned long rank;\n        //如果是跳表,也是先取出第一个元素\n        /* Find first element in range */\n        zn = zslFirstInRange(zsl, &range);\n\n        /* Use rank of first element, if any, to determine preliminary count */\n        if (zn != NULL) {\n            //获取第一个元素的排名\n            rank = zslGetRank(zsl, zn->score, zn->ele);\n            count = (zsl->length - (rank - 1));\n            //如果最大值大于zsl中的最大值,则此count就是要找的个数\n            /* Find last element in range */\n            zn = zslLastInRange(zsl, &range);\n\n            /* Use rank of last element, if any, to determine the actual count */\n            if (zn != NULL) {\n                //如果最大值小于zsl中的最大值，则首先找到最后一个元素的rank\n                rank = zslGetRank(zsl, zn->score, zn->ele);\n                //重新计算count,与之前的计算公式合并之后为\n                //count = (zsl->length-(rankmin-1))-(zsl->length-rankmax))\n                //      = rankmax-rankmin+1\n                count -= (zsl->length - rank);\n            }\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n    //返回count\n    addReplyLongLong(c, count);\n}\n```\n\n## ZRANGEBYSCORE\nZRANGEBYSCORE key min max [WITHSCORES][LIMIT offset count]\n\n获取有序结合中分值位于 min和max之间的所有元素\n\nwithscores:将member 和 score一起返回 \n\nlimit offset count:从偏移offset开始获取count个元素\n\nmin和max可以为 -inf,+inf,分别表示负无穷和正无穷\n\n```c\n\n//入口函数\nvoid zrangebyscoreCommand(client *c) {\n    genericZrangebyscoreCommand(c,0);\n}\n\n```\n\n```c\n/* This command implements ZRANGEBYSCORE, ZREVRANGEBYSCORE. */\nvoid genericZrangebyscoreCommand(client *c, int reverse) {\n    zrangespec range;\n    robj *key = c->argv[1];\n    robj *zobj;\n    long offset = 0, limit = -1;\n    int withscores = 0;\n    unsigned long rangelen = 0;\n    void *replylen = NULL;\n    int minidx, maxidx;\n    //该函数同时用于zrangbyscore和zrevrangebyscore\n    //二者通过函数中的reverse参数标识\n    //正序时第二个参数是min，第三个参数是max,逆序反之\n    /* Parse the range arguments. */\n    if (reverse) {\n        /* Range is given as [max,min] */\n        maxidx = 2; minidx = 3;\n    } else {\n        /* Range is given as [min,max] */\n        minidx = 2; maxidx = 3;\n    }\n    //将参数解析出来赋值到range变量\n    if (zslParseRange(c->argv[minidx],c->argv[maxidx],&range) != C_OK) {\n        addReplyError(c,\"min or max is not a float\");\n        return;\n    }\n\n    /* Parse optional extra arguments. Note that ZCOUNT will exactly have\n     * 4 arguments, so we'll never enter the following code path. */\n    if (c->argc > 4) {\n        int remaining = c->argc - 4;\n        int pos = 4;\n        //解析withscores和limit参数\n        while (remaining) {\n            if (remaining >= 1 && !strcasecmp(c->argv[pos]->ptr,\"withscores\")) {\n                pos++; remaining--;\n                withscores = 1;\n            } else if (remaining >= 3 && !strcasecmp(c->argv[pos]->ptr,\"limit\")) {\n                if ((getLongFromObjectOrReply(c, c->argv[pos+1], &offset, NULL)\n                        != C_OK) ||\n                    (getLongFromObjectOrReply(c, c->argv[pos+2], &limit, NULL)\n                        != C_OK))\n                {\n                    return;\n                }\n                pos += 3; remaining -= 3;\n            } else {\n                addReply(c,shared.syntaxerr);\n                return;\n            }\n        }\n    }\n\n    /* Ok, lookup the key and get the range */\n    if ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == NULL ||\n        checkType(c,zobj,OBJ_ZSET)) return;\n    //按zset底层编码是ziplist还是skiplist分别处理\n    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {\n        unsigned char *zl = zobj->ptr;\n        unsigned char *eptr, *sptr;\n        unsigned char *vstr;\n        unsigned int vlen;\n        long long vlong;\n        double score;\n\n        /* If reversed, get the last node in range as starting point. */\n        //按正序还是逆序分别取最后一个值或者第一个值\n        if (reverse) {\n            eptr = zzlLastInRange(zl,&range);\n        } else {\n            eptr = zzlFirstInRange(zl,&range);\n        }\n\n        /* No \"first\" element in the specified interval. */\n        if (eptr == NULL) {\n            addReply(c, shared.emptymultibulk);\n            return;\n        }\n\n        /* Get score pointer for the first element. */\n        serverAssertWithInfo(c,zobj,eptr != NULL);\n        sptr = ziplistNext(zl,eptr);\n\n        /* We don't know in advance how many matching elements there are in the\n         * list, so we push this object that will represent the multi-bulk\n         * length in the output buffer, and will \"fix\" it later */\n        replylen = addDeferredMultiBulkLength(c);\n\n        /* If there is an offset, just traverse the number of elements without\n         * checking the score because that is done in the next loop. */\n        //如果有offset,先偏移相应的元素\n        //注意此处zzlNext传入了两个指针,会一次偏移一个<member,score>对\n        //注意此处offset初始值是0,如果没指定则不会进入此处循环\n        while (eptr && offset--) {\n            if (reverse) {\n                zzlPrev(zl,&eptr,&sptr);\n            } else {\n                zzlNext(zl,&eptr,&sptr);\n            }\n        }\n\n        //如果有limit,则进入循环.取limit次.limit的初始值为-1,即使没指定,也会进入循环\n        //直到eptr为null或者循环中break掉\n        while (eptr && limit--) {\n            score = zzlGetScore(sptr);\n\n            /* Abort when the node is no longer in range. */\n            //不在范围之内时break掉\n            if (reverse) {\n                if (!zslValueGteMin(score,&range)) break;\n            } else {\n                if (!zslValueLteMax(score,&range)) break;\n            }\n\n            /* We know the element exists, so ziplistGet should always succeed */\n            serverAssertWithInfo(c,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));\n            //取出相应的值.可能为str,赋值给vstr,长度为vlen,或者为整型,赋值给vlong\n            rangelen++;\n            if (vstr == NULL) {\n                addReplyBulkLongLong(c,vlong);\n            } else {\n                addReplyBulkCBuffer(c,vstr,vlen);\n            }\n            //如果设置了withscores标志,则返回分数\n            if (withscores) {\n                addReplyDouble(c,score);\n            }\n            //开始迭代下一个节点\n            /* Move to next node */\n            if (reverse) {\n                zzlPrev(zl,&eptr,&sptr);\n            } else {\n                zzlNext(zl,&eptr,&sptr);\n            }\n        }\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        zskiplist *zsl = zs->zsl;\n        zskiplistNode *ln;\n\n        //同ziplist,先查找起始或最终节点\n        /* If reversed, get the last node in range as starting point. */\n        if (reverse) {\n            ln = zslLastInRange(zsl,&range);\n        } else {\n            ln = zslFirstInRange(zsl,&range);\n        }\n\n        /* No \"first\" element in the specified interval. */\n        if (ln == NULL) {\n            addReply(c, shared.emptymultibulk);\n            return;\n        }\n\n        /* We don't know in advance how many matching elements there are in the\n         * list, so we push this object that will represent the multi-bulk\n         * length in the output buffer, and will \"fix\" it later */\n        //返回客户端时先返回元素个数,但此处并不知道需要返回多少个元素,所以先占个位置\n        //replylen是存储len字段的指针\n        replylen = addDeferredMultiBulkLength(c);\n\n        /* If there is an offset, just traverse the number of elements without\n         * checking the score because that is done in the next loop. */\n        //处理offset.向前或向后skip\n        while (ln && offset--) {\n            if (reverse) {\n                ln = ln->backward;\n            } else {\n                ln = ln->level[0].forward;\n            }\n        }\n\n        //处理limit\n        while (ln && limit--) {\n            /* Abort when the node is no longer in range. */\n            if (reverse) {\n                if (!zslValueGteMin(ln->score,&range)) break;\n            } else {\n                if (!zslValueLteMax(ln->score,&range)) break;\n            }\n\n            rangelen++;\n            addReplyBulkCBuffer(c,ln->ele,sdslen(ln->ele));\n\n            if (withscores) {\n                addReplyDouble(c,ln->score);\n            }\n\n            /* Move to next node */\n            if (reverse) {\n                ln = ln->backward;\n            } else {\n                ln = ln->level[0].forward;\n            }\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n    //如果有withscores参数,返回给客户端的字符串数量是2倍\n    if (withscores) {\n        rangelen *= 2;\n    }\n    //将rangelen放入replylen指向的位置,返回给客户端\n    setDeferredMultiBulkLength(c, replylen, rangelen);\n}\n```\n\n## ZRANK\nZRANK key member\n\n返回有序集合中元素member的rank\n\n以0为起始rank,元素分数从低到高\n\nzrevrank,元素分数从高到低\n\n```c\nvoid zrankGenericCommand(client *c, int reverse) {\n    robj *key = c->argv[1];\n    robj *ele = c->argv[2];\n    robj *zobj;\n    long rank;\n    //通过key找出有序集合的value zobj\n    if ((zobj = lookupKeyReadOrReply(c,key,shared.nullbulk)) == NULL ||\n        checkType(c,zobj,OBJ_ZSET)) return;\n\n    serverAssertWithInfo(c,ele,sdsEncodedObject(ele));\n    //在zobj中查找ele(第二个参数member)\n    rank = zsetRank(zobj,ele->ptr,reverse);\n    if (rank >= 0) {\n        addReplyLongLong(c,rank);\n    } else {\n        addReply(c,shared.nullbulk);\n    }\n}\n\nvoid zrankCommand(client *c) {\n    zrankGenericCommand(c, 0);\n}\n```\n```c\nlong zsetRank(robj *zobj, sds ele, int reverse) {\n    unsigned long llen;\n    unsigned long rank;\n\n    llen = zsetLength(zobj);\n    //ziplist从前往后遍历,比较entry中的元素与ele,每次将rank++\n    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {\n        unsigned char *zl = zobj->ptr;\n        unsigned char *eptr, *sptr;\n\n        eptr = ziplistIndex(zl,0);\n        serverAssert(eptr != NULL);\n        sptr = ziplistNext(zl,eptr);\n        serverAssert(sptr != NULL);\n\n        rank = 1;\n        while(eptr != NULL) {\n            if (ziplistCompare(eptr,(unsigned char*)ele,sdslen(ele)))\n                break;\n            rank++;\n            zzlNext(zl,&eptr,&sptr);\n        }\n\n        if (eptr != NULL) {\n            //如果是逆序取,直接将llen-rank就是逆向的rank\n            if (reverse)\n                return llen-rank;\n            else\n                return rank-1;\n        } else {\n            return -1;\n        }\n    //skiplist通过zslGetRank获取rank,具体过程为跳表查找,将相应路过节点的span相加\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        zskiplist *zsl = zs->zsl;\n        dictEntry *de;\n        double score;\n\n        de = dictFind(zs->dict,ele);\n        if (de != NULL) {\n            score = *(double*)dictGetVal(de);\n            rank = zslGetRank(zsl,score,ele);\n            /* Existing elements always have a rank. */\n            serverAssert(rank != 0);\n            //逆向取rank\n            if (reverse)\n                return llen-rank;\n            else\n                return rank-1;\n        } else {\n            return -1;\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n}\n```\n\n## ZREM\nZREM key member [member ...]\n\n从有序集合中删除相应的member\n\n\n```c\nvoid zremCommand(client *c) {\n    robj *key = c->argv[1];\n    robj *zobj;\n    int deleted = 0, keyremoved = 0, j;\n    //根据key找到对应的zobj\n    if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||\n        checkType(c,zobj,OBJ_ZSET)) return;\n    //依次删除相应的元素,每次删除之后检查zset是否为空,如果为空,删掉该key,并且break\n    for (j = 2; j < c->argc; j++) {\n        if (zsetDel(zobj,c->argv[j]->ptr)) deleted++;\n        if (zsetLength(zobj) == 0) {\n            dbDelete(c->db,key);\n            keyremoved = 1;\n            break;\n        }\n    }\n    //如果确实有member被删除掉,通知keyspace zrem事件\n    //如果zset整个都被删除了,通知keyspace del事件\n    if (deleted) {\n        notifyKeyspaceEvent(NOTIFY_ZSET,\"zrem\",key,c->db->id);\n        if (keyremoved)\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",key,c->db->id);\n        signalModifiedKey(c->db,key);\n        server.dirty += deleted;\n    }\n    //返回给客户端实际删除的member个数\n    addReplyLongLong(c,deleted);\n}\n```\n\n```c\n/* Delete the element 'ele' from the sorted set, returning 1 if the element\n * existed and was deleted, 0 otherwise (the element was not there). */\nint zsetDel(robj *zobj, sds ele) {\n    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {\n        unsigned char *eptr;\n        //ziplist先找到ele所在位置的指针eptr\n        if ((eptr = zzlFind(zobj->ptr,ele,NULL)) != NULL) {\n            //将该元素删除.ziplist删除时会resize,此处将删除之后ziplist的指针复值给zobj->ptr\n            zobj->ptr = zzlDelete(zobj->ptr,eptr);\n            return 1;\n        }\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = zobj->ptr;\n        dictEntry *de;\n        double score;\n        //skiplist现将zobj->ptr->dict相应的ele删除掉。此处并未真实删除\n        //而是将ele所在的dictEntry返回\n        de = dictUnlink(zs->dict,ele);\n        if (de != NULL) {\n            /* Get the score in order to delete from the skiplist later. */\n            //通过dictEntry获取score\n            score = *(double*)dictGetVal(de);\n\n            /* Delete from the hash table and later from the skiplist.\n             * Note that the order is important: deleting from the skiplist\n             * actually releases the SDS string representing the element,\n             * which is shared between the skiplist and the hash table, so\n             * we need to delete from the skiplist as the final step. */\n            //此处将dict中的key和value实际free掉\n            dictFreeUnlinkedEntry(zs->dict,de);\n\n            /* Delete from skiplist. */\n            //从skiplist中删除元素.ele这个sds在hash和skiplist共享.从skiplist中删除时\n            //会释放此sds,所以必须先删除dict中的元素再删除skiplist中的元素\n            int retval = zslDelete(zs->zsl,score,ele,NULL);\n            serverAssert(retval);\n            //如果hash表中元素使用率小于10%,进行dict的resize\n            if (htNeedsResize(zs->dict)) dictResize(zs->dict);\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n    return 0; /* No such element found. */\n}\n```","slug":"Redis有序集合指令学习","published":1,"updated":"2019-02-19T05:27:46.815Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsbcaujf0003zlfy6thr95dk","content":"<h2 id=\"ZADD\"><a href=\"#ZADD\" class=\"headerlink\" title=\"ZADD\"></a>ZADD</h2><p>ZADD key [NX|XX] [CH] [INCR]score member [score member …]</p>\n<p>将元素及对应分值添加到一个有序集合中</p>\n<p>NX:不更新已经存在的key,只增加新元素</p>\n<p>XX:只更新已经存在的key,不增加新元素</p>\n<p>CH:abbr:changed.不指定时只返回新增的元素个数,指定时返回新增的和更新的元素个数之和</p>\n<p>INCR:参考zincrby</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过第二个参数区分是zadd还是zincrby</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">zaddCommand</span><span class=\"params\">(client *c)</span> </span>&#123;</span><br><span class=\"line\">    zaddGenericCommand(c,ZADD_NONE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* This generic command implements both ZADD and ZINCRBY. */</span></span><br><span class=\"line\"><span class=\"comment\">//zadd和zincrby两个命令都是调用这个函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">zaddGenericCommand</span><span class=\"params\">(client *c, <span class=\"keyword\">int</span> flags)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">char</span> *nanerr = <span class=\"string\">\"resulting score is not a number (NaN)\"</span>;</span><br><span class=\"line\">    robj *key = c-&gt;argv[<span class=\"number\">1</span>];</span><br><span class=\"line\">    robj *zobj;</span><br><span class=\"line\">    sds ele;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> score = <span class=\"number\">0</span>, *scores = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j, elements;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> scoreidx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* The following vars are used in order to track what the command actually</span></span><br><span class=\"line\"><span class=\"comment\">     * did during the execution, to reply to the client and to trigger the</span></span><br><span class=\"line\"><span class=\"comment\">     * notification of keyspace change. */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> added = <span class=\"number\">0</span>;      <span class=\"comment\">/* Number of new elements added. */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> updated = <span class=\"number\">0</span>;    <span class=\"comment\">/* Number of elements with updated score. */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> processed = <span class=\"number\">0</span>;  <span class=\"comment\">/* Number of elements processed, may remain zero with</span></span><br><span class=\"line\"><span class=\"comment\">                           options like XX. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Parse options. At the end 'scoreidx' is set to the argument position</span></span><br><span class=\"line\"><span class=\"comment\">     * of the score of the first score-element pair. */</span></span><br><span class=\"line\">    scoreidx = <span class=\"number\">2</span>;<span class=\"comment\">//从第二个参数开始处理.先处理nx,xx,ch,incr参数</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(scoreidx &lt; c-&gt;argc) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> *opt = c-&gt;argv[scoreidx]-&gt;ptr;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!strcasecmp(opt,<span class=\"string\">\"nx\"</span>)) flags |= ZADD_NX;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!strcasecmp(opt,<span class=\"string\">\"xx\"</span>)) flags |= ZADD_XX;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!strcasecmp(opt,<span class=\"string\">\"ch\"</span>)) flags |= ZADD_CH;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!strcasecmp(opt,<span class=\"string\">\"incr\"</span>)) flags |= ZADD_INCR;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        scoreidx++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Turn options into simple to check vars. */</span></span><br><span class=\"line\">    <span class=\"comment\">//从flag中取出相应的标志赋给独立的变量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> incr = (flags &amp; ZADD_INCR) != <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nx = (flags &amp; ZADD_NX) != <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> xx = (flags &amp; ZADD_XX) != <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ch = (flags &amp; ZADD_CH) != <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* After the options, we expect to have an even number of args, since</span></span><br><span class=\"line\"><span class=\"comment\">     * we expect any number of score-element pairs. */</span></span><br><span class=\"line\">    <span class=\"comment\">//member和score是一一对应的,所以肯定是2的倍数.所以如果不是2的倍数或者根本</span></span><br><span class=\"line\">    <span class=\"comment\">//没有member和score,直接返回命令语法错误</span></span><br><span class=\"line\">    elements = c-&gt;argc-scoreidx;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elements % <span class=\"number\">2</span> || !elements) &#123;</span><br><span class=\"line\">        addReply(c,shared.syntaxerr);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//elements赋值为有多少对&lt;element,score&gt;</span></span><br><span class=\"line\">    elements /= <span class=\"number\">2</span>; <span class=\"comment\">/* Now this holds the number of score-element pairs. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Check for incompatible options. */</span></span><br><span class=\"line\">    <span class=\"comment\">//nx和xxflag互斥,二者不能同时出现</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nx &amp;&amp; xx) &#123;</span><br><span class=\"line\">        addReplyError(c,</span><br><span class=\"line\">            <span class=\"string\">\"XX and NX options at the same time are not compatible\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//若有incr标志,则只能有一对&lt;element,score&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">//为什么不能是多对?</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (incr &amp;&amp; elements &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        addReplyError(c,</span><br><span class=\"line\">            <span class=\"string\">\"INCR option supports a single increment-element pair\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Start parsing all the scores, we need to emit any syntax error</span></span><br><span class=\"line\"><span class=\"comment\">     * before executing additions to the sorted set, as the command should</span></span><br><span class=\"line\"><span class=\"comment\">     * either execute fully or nothing at all. */</span></span><br><span class=\"line\">    <span class=\"comment\">//依次检查每一个分数值</span></span><br><span class=\"line\">    scores = zmalloc(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">double</span>)*elements);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; elements; j++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//该函数中会检查score是否是合法的double类型的值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (getDoubleFromObjectOrReply(c,c-&gt;argv[scoreidx+j*<span class=\"number\">2</span>],&amp;scores[j],<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            != C_OK) <span class=\"keyword\">goto</span> cleanup;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Lookup the key and create the sorted set if does not exist. */</span></span><br><span class=\"line\">    <span class=\"comment\">//根据key查找对应的有序集合的value</span></span><br><span class=\"line\">    zobj = lookupKeyWrite(c-&gt;db,key);</span><br><span class=\"line\">    <span class=\"comment\">//key不存在</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zobj == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果设置了xx这个flag,直接返回错误</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (xx) <span class=\"keyword\">goto</span> reply_to_client; <span class=\"comment\">/* No key + XX option: nothing to do. */</span></span><br><span class=\"line\">        <span class=\"comment\">//根据redis的配置,如果有序集合设置了不使用ziplist存储或者说第一个插入元素的长度大于</span></span><br><span class=\"line\">        <span class=\"comment\">//设置的最大ziplist的元素长度值,则使用跳跃表存储否则使用ziplist</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (server.zset_max_ziplist_entries == <span class=\"number\">0</span> ||</span><br><span class=\"line\">            server.zset_max_ziplist_value &lt; sdslen(c-&gt;argv[scoreidx+<span class=\"number\">1</span>]-&gt;ptr))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            zobj = createZsetObject();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            zobj = createZsetZiplistObject();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//把key,zobj插入字典</span></span><br><span class=\"line\">        dbAdd(c-&gt;db,key,zobj);</span><br><span class=\"line\">    <span class=\"comment\">//key存在</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果不是有序集合,直接返回错误</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (zobj-&gt;type != OBJ_ZSET) &#123;</span><br><span class=\"line\">            addReply(c,shared.wrongtypeerr);</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> cleanup;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//elements是&lt;member,score&gt;对数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; elements; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> newscore;</span><br><span class=\"line\">        score = scores[j];</span><br><span class=\"line\">        <span class=\"comment\">//retflags设置为前文中的flags变量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> retflags = flags;</span><br><span class=\"line\"></span><br><span class=\"line\">        ele = c-&gt;argv[scoreidx+<span class=\"number\">1</span>+j*<span class=\"number\">2</span>]-&gt;ptr;</span><br><span class=\"line\">        <span class=\"comment\">//每次遍历,score是分数,ele是member.调用zsetadd插入zobj</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> retval = zsetAdd(zobj, score, ele, &amp;retflags, &amp;newscore);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (retval == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            addReplyError(c,nanerr);</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> cleanup;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//根据retflags,即一个元素是更新还是新加入,还是未做处理(即member存在,并且</span></span><br><span class=\"line\">        <span class=\"comment\">//score值与新设置的一致),更新相应的计数变量(这些变量最后会返回给客户端)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (retflags &amp; ZADD_ADDED) added++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (retflags &amp; ZADD_UPDATED) updated++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(retflags &amp; ZADD_NOP)) processed++;</span><br><span class=\"line\">        score = newscore;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    server.dirty += (added+updated);</span><br><span class=\"line\"><span class=\"comment\">//通过命令中的flag,返回给客户端不同的值</span></span><br><span class=\"line\">reply_to_client:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (incr) &#123; <span class=\"comment\">/* ZINCRBY or INCR option. */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (processed)</span><br><span class=\"line\">            addReplyDouble(c,score);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            addReply(c,shared.nullbulk);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">/* ZADD. */</span></span><br><span class=\"line\">        addReplyLongLong(c,ch ? added+updated : added);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果有更新或者新加,需要执行相应的watch key的通知及keyspace的通知</span></span><br><span class=\"line\">cleanup:</span><br><span class=\"line\">    zfree(scores);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (added || updated) &#123;</span><br><span class=\"line\">        signalModifiedKey(c-&gt;db,key);</span><br><span class=\"line\">        notifyKeyspaceEvent(NOTIFY_ZSET,</span><br><span class=\"line\">            incr ? <span class=\"string\">\"zincr\"</span> : <span class=\"string\">\"zadd\"</span>, key, c-&gt;db-&gt;id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ZINCRBY\"><a href=\"#ZINCRBY\" class=\"headerlink\" title=\"ZINCRBY\"></a>ZINCRBY</h2><p>ZINCRBY key increment member</p>\n<p>如果key存在,就给相应member的score增加increment</p>\n<p>否则直接给key设置分数为increment</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//与zadd调用同一个函数,相当于zadd key incr,把incr flag置位</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">zincrbyCommand</span><span class=\"params\">(client *c)</span> </span>&#123;</span><br><span class=\"line\">    zaddGenericCommand(c,ZADD_INCR);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ZCARD\"><a href=\"#ZCARD\" class=\"headerlink\" title=\"ZCARD\"></a>ZCARD</h2><p>ZCARD key</p>\n<p>返回有序集合的元素个数<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">zcardCommand</span><span class=\"params\">(client *c)</span> </span>&#123;</span><br><span class=\"line\">    robj *key = c-&gt;argv[<span class=\"number\">1</span>];</span><br><span class=\"line\">    robj *zobj;</span><br><span class=\"line\">    <span class=\"comment\">//查找key对应的value</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((zobj = lookupKeyReadOrReply(c,key,shared.czero)) == <span class=\"literal\">NULL</span> ||</span><br><span class=\"line\">        checkType(c,zobj,OBJ_ZSET)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">//通过zsetLength获取zobj中的元素个数</span></span><br><span class=\"line\">    addReplyLongLong(c,zsetLength(zobj));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">zsetLength</span><span class=\"params\">(<span class=\"keyword\">const</span> robj *zobj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//如果是ziplist,通过zzlLength函数获取长度</span></span><br><span class=\"line\">    <span class=\"comment\">//如果长度字段中的值小于UINT16_MAX，直接返回长度。否则需要遍历获取长度</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class=\"line\">        length = zzlLength(zobj-&gt;ptr);</span><br><span class=\"line\">    <span class=\"comment\">//如果是skiplist,直接返回zsl-&gt;length</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class=\"line\">        length = ((<span class=\"keyword\">const</span> zset*)zobj-&gt;ptr)-&gt;zsl-&gt;length;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        serverPanic(<span class=\"string\">\"Unknown sorted set encoding\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> length;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ZCOUNT\"><a href=\"#ZCOUNT\" class=\"headerlink\" title=\"ZCOUNT\"></a>ZCOUNT</h2><p>ZCOUNT key min max</p>\n<p>返回key中score值在min和max之间的元素个数</p>\n<p>其中min和max可以加(,如 zcount key (5 (10 </p>\n<p>加左括号表示不包含。不加表示包含</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">zcountCommand</span><span class=\"params\">(client *c)</span> </span>&#123;</span><br><span class=\"line\">    robj *key = c-&gt;argv[<span class=\"number\">1</span>];</span><br><span class=\"line\">    robj *zobj;</span><br><span class=\"line\">    zrangespec range;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Parse the range arguments */</span></span><br><span class=\"line\">    <span class=\"comment\">//判定范围.并将最大最小及是否包含写入range结构体中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zslParseRange(c-&gt;argv[<span class=\"number\">2</span>],c-&gt;argv[<span class=\"number\">3</span>],&amp;range) != C_OK) &#123;</span><br><span class=\"line\">        addReplyError(c,<span class=\"string\">\"min or max is not a float\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Lookup the sorted set */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == <span class=\"literal\">NULL</span> ||</span><br><span class=\"line\">        checkType(c, zobj, OBJ_ZSET)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">//判断zobj底层编码是ziplist还是skiplist</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *zl = zobj-&gt;ptr;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *eptr, *sptr;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> score;</span><br><span class=\"line\">        <span class=\"comment\">//找出第一个在范围之内的元素</span></span><br><span class=\"line\">        <span class=\"comment\">/* Use the first element in range as the starting point */</span></span><br><span class=\"line\">        eptr = zzlFirstInRange(zl,&amp;range);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* No \"first\" element */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (eptr == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            addReply(c, shared.czero);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* First element is in range */</span></span><br><span class=\"line\">        <span class=\"comment\">//ziplist中member和score是两个entry,并且member之后保存着score</span></span><br><span class=\"line\">        <span class=\"comment\">//整体顺序是按score从小到大排列,score相同时,按member的字典序排列</span></span><br><span class=\"line\">        sptr = ziplistNext(zl,eptr);</span><br><span class=\"line\">        <span class=\"comment\">//所以此处从第一个元素的下一个entry处获取score</span></span><br><span class=\"line\">        score = zzlGetScore(sptr);</span><br><span class=\"line\">        serverAssertWithInfo(c,zobj,zslValueLteMax(score,&amp;range));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Iterate over elements in range */</span></span><br><span class=\"line\">        <span class=\"comment\">//迭代这个ziplist,如果score满足要求,则count++并且继续迭代,否则跳出</span></span><br><span class=\"line\">        <span class=\"comment\">//最后会返回count</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (eptr) &#123;</span><br><span class=\"line\">            score = zzlGetScore(sptr);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/* Abort when the node is no longer in range. */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!zslValueLteMax(score,&amp;range)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">                zzlNext(zl,&amp;eptr,&amp;sptr);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class=\"line\">        zset *zs = zobj-&gt;ptr;</span><br><span class=\"line\">        zskiplist *zsl = zs-&gt;zsl;</span><br><span class=\"line\">        zskiplistNode *zn;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> rank;</span><br><span class=\"line\">        <span class=\"comment\">//如果是跳表,也是先取出第一个元素</span></span><br><span class=\"line\">        <span class=\"comment\">/* Find first element in range */</span></span><br><span class=\"line\">        zn = zslFirstInRange(zsl, &amp;range);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Use rank of first element, if any, to determine preliminary count */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (zn != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取第一个元素的排名</span></span><br><span class=\"line\">            rank = zslGetRank(zsl, zn-&gt;score, zn-&gt;ele);</span><br><span class=\"line\">            count = (zsl-&gt;length - (rank - <span class=\"number\">1</span>));</span><br><span class=\"line\">            <span class=\"comment\">//如果最大值大于zsl中的最大值,则此count就是要找的个数</span></span><br><span class=\"line\">            <span class=\"comment\">/* Find last element in range */</span></span><br><span class=\"line\">            zn = zslLastInRange(zsl, &amp;range);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/* Use rank of last element, if any, to determine the actual count */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (zn != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果最大值小于zsl中的最大值，则首先找到最后一个元素的rank</span></span><br><span class=\"line\">                rank = zslGetRank(zsl, zn-&gt;score, zn-&gt;ele);</span><br><span class=\"line\">                <span class=\"comment\">//重新计算count,与之前的计算公式合并之后为</span></span><br><span class=\"line\">                <span class=\"comment\">//count = (zsl-&gt;length-(rankmin-1))-(zsl-&gt;length-rankmax))</span></span><br><span class=\"line\">                <span class=\"comment\">//      = rankmax-rankmin+1</span></span><br><span class=\"line\">                count -= (zsl-&gt;length - rank);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        serverPanic(<span class=\"string\">\"Unknown sorted set encoding\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//返回count</span></span><br><span class=\"line\">    addReplyLongLong(c, count);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ZRANGEBYSCORE\"><a href=\"#ZRANGEBYSCORE\" class=\"headerlink\" title=\"ZRANGEBYSCORE\"></a>ZRANGEBYSCORE</h2><p>ZRANGEBYSCORE key min max [WITHSCORES][LIMIT offset count]</p>\n<p>获取有序结合中分值位于 min和max之间的所有元素</p>\n<p>withscores:将member 和 score一起返回 </p>\n<p>limit offset count:从偏移offset开始获取count个元素</p>\n<p>min和max可以为 -inf,+inf,分别表示负无穷和正无穷</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//入口函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">zrangebyscoreCommand</span><span class=\"params\">(client *c)</span> </span>&#123;</span><br><span class=\"line\">    genericZrangebyscoreCommand(c,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* This command implements ZRANGEBYSCORE, ZREVRANGEBYSCORE. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">genericZrangebyscoreCommand</span><span class=\"params\">(client *c, <span class=\"keyword\">int</span> reverse)</span> </span>&#123;</span><br><span class=\"line\">    zrangespec range;</span><br><span class=\"line\">    robj *key = c-&gt;argv[<span class=\"number\">1</span>];</span><br><span class=\"line\">    robj *zobj;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> offset = <span class=\"number\">0</span>, limit = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> withscores = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> rangelen = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *replylen = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> minidx, maxidx;</span><br><span class=\"line\">    <span class=\"comment\">//该函数同时用于zrangbyscore和zrevrangebyscore</span></span><br><span class=\"line\">    <span class=\"comment\">//二者通过函数中的reverse参数标识</span></span><br><span class=\"line\">    <span class=\"comment\">//正序时第二个参数是min，第三个参数是max,逆序反之</span></span><br><span class=\"line\">    <span class=\"comment\">/* Parse the range arguments. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (reverse) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* Range is given as [max,min] */</span></span><br><span class=\"line\">        maxidx = <span class=\"number\">2</span>; minidx = <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* Range is given as [min,max] */</span></span><br><span class=\"line\">        minidx = <span class=\"number\">2</span>; maxidx = <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将参数解析出来赋值到range变量</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zslParseRange(c-&gt;argv[minidx],c-&gt;argv[maxidx],&amp;range) != C_OK) &#123;</span><br><span class=\"line\">        addReplyError(c,<span class=\"string\">\"min or max is not a float\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Parse optional extra arguments. Note that ZCOUNT will exactly have</span></span><br><span class=\"line\"><span class=\"comment\">     * 4 arguments, so we'll never enter the following code path. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c-&gt;argc &gt; <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> remaining = c-&gt;argc - <span class=\"number\">4</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pos = <span class=\"number\">4</span>;</span><br><span class=\"line\">        <span class=\"comment\">//解析withscores和limit参数</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (remaining) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (remaining &gt;= <span class=\"number\">1</span> &amp;&amp; !strcasecmp(c-&gt;argv[pos]-&gt;ptr,<span class=\"string\">\"withscores\"</span>)) &#123;</span><br><span class=\"line\">                pos++; remaining--;</span><br><span class=\"line\">                withscores = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (remaining &gt;= <span class=\"number\">3</span> &amp;&amp; !strcasecmp(c-&gt;argv[pos]-&gt;ptr,<span class=\"string\">\"limit\"</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[pos+<span class=\"number\">1</span>], &amp;offset, <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                        != C_OK) ||</span><br><span class=\"line\">                    (getLongFromObjectOrReply(c, c-&gt;argv[pos+<span class=\"number\">2</span>], &amp;limit, <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                        != C_OK))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                pos += <span class=\"number\">3</span>; remaining -= <span class=\"number\">3</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                addReply(c,shared.syntaxerr);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Ok, lookup the key and get the range */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == <span class=\"literal\">NULL</span> ||</span><br><span class=\"line\">        checkType(c,zobj,OBJ_ZSET)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">//按zset底层编码是ziplist还是skiplist分别处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *zl = zobj-&gt;ptr;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *eptr, *sptr;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *vstr;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> vlen;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> vlong;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> score;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* If reversed, get the last node in range as starting point. */</span></span><br><span class=\"line\">        <span class=\"comment\">//按正序还是逆序分别取最后一个值或者第一个值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (reverse) &#123;</span><br><span class=\"line\">            eptr = zzlLastInRange(zl,&amp;range);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            eptr = zzlFirstInRange(zl,&amp;range);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* No \"first\" element in the specified interval. */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (eptr == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            addReply(c, shared.emptymultibulk);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Get score pointer for the first element. */</span></span><br><span class=\"line\">        serverAssertWithInfo(c,zobj,eptr != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        sptr = ziplistNext(zl,eptr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* We don't know in advance how many matching elements there are in the</span></span><br><span class=\"line\"><span class=\"comment\">         * list, so we push this object that will represent the multi-bulk</span></span><br><span class=\"line\"><span class=\"comment\">         * length in the output buffer, and will \"fix\" it later */</span></span><br><span class=\"line\">        replylen = addDeferredMultiBulkLength(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* If there is an offset, just traverse the number of elements without</span></span><br><span class=\"line\"><span class=\"comment\">         * checking the score because that is done in the next loop. */</span></span><br><span class=\"line\">        <span class=\"comment\">//如果有offset,先偏移相应的元素</span></span><br><span class=\"line\">        <span class=\"comment\">//注意此处zzlNext传入了两个指针,会一次偏移一个&lt;member,score&gt;对</span></span><br><span class=\"line\">        <span class=\"comment\">//注意此处offset初始值是0,如果没指定则不会进入此处循环</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (eptr &amp;&amp; offset--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reverse) &#123;</span><br><span class=\"line\">                zzlPrev(zl,&amp;eptr,&amp;sptr);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                zzlNext(zl,&amp;eptr,&amp;sptr);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果有limit,则进入循环.取limit次.limit的初始值为-1,即使没指定,也会进入循环</span></span><br><span class=\"line\">        <span class=\"comment\">//直到eptr为null或者循环中break掉</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (eptr &amp;&amp; limit--) &#123;</span><br><span class=\"line\">            score = zzlGetScore(sptr);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/* Abort when the node is no longer in range. */</span></span><br><span class=\"line\">            <span class=\"comment\">//不在范围之内时break掉</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reverse) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!zslValueGteMin(score,&amp;range)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!zslValueLteMax(score,&amp;range)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/* We know the element exists, so ziplistGet should always succeed */</span></span><br><span class=\"line\">            serverAssertWithInfo(c,zobj,ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vlong));</span><br><span class=\"line\">            <span class=\"comment\">//取出相应的值.可能为str,赋值给vstr,长度为vlen,或者为整型,赋值给vlong</span></span><br><span class=\"line\">            rangelen++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (vstr == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">                addReplyBulkLongLong(c,vlong);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                addReplyBulkCBuffer(c,vstr,vlen);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//如果设置了withscores标志,则返回分数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (withscores) &#123;</span><br><span class=\"line\">                addReplyDouble(c,score);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//开始迭代下一个节点</span></span><br><span class=\"line\">            <span class=\"comment\">/* Move to next node */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reverse) &#123;</span><br><span class=\"line\">                zzlPrev(zl,&amp;eptr,&amp;sptr);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                zzlNext(zl,&amp;eptr,&amp;sptr);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class=\"line\">        zset *zs = zobj-&gt;ptr;</span><br><span class=\"line\">        zskiplist *zsl = zs-&gt;zsl;</span><br><span class=\"line\">        zskiplistNode *ln;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//同ziplist,先查找起始或最终节点</span></span><br><span class=\"line\">        <span class=\"comment\">/* If reversed, get the last node in range as starting point. */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (reverse) &#123;</span><br><span class=\"line\">            ln = zslLastInRange(zsl,&amp;range);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ln = zslFirstInRange(zsl,&amp;range);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* No \"first\" element in the specified interval. */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ln == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            addReply(c, shared.emptymultibulk);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* We don't know in advance how many matching elements there are in the</span></span><br><span class=\"line\"><span class=\"comment\">         * list, so we push this object that will represent the multi-bulk</span></span><br><span class=\"line\"><span class=\"comment\">         * length in the output buffer, and will \"fix\" it later */</span></span><br><span class=\"line\">        <span class=\"comment\">//返回客户端时先返回元素个数,但此处并不知道需要返回多少个元素,所以先占个位置</span></span><br><span class=\"line\">        <span class=\"comment\">//replylen是存储len字段的指针</span></span><br><span class=\"line\">        replylen = addDeferredMultiBulkLength(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* If there is an offset, just traverse the number of elements without</span></span><br><span class=\"line\"><span class=\"comment\">         * checking the score because that is done in the next loop. */</span></span><br><span class=\"line\">        <span class=\"comment\">//处理offset.向前或向后skip</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (ln &amp;&amp; offset--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reverse) &#123;</span><br><span class=\"line\">                ln = ln-&gt;backward;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ln = ln-&gt;level[<span class=\"number\">0</span>].forward;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//处理limit</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (ln &amp;&amp; limit--) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* Abort when the node is no longer in range. */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reverse) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!zslValueGteMin(ln-&gt;score,&amp;range)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!zslValueLteMax(ln-&gt;score,&amp;range)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            rangelen++;</span><br><span class=\"line\">            addReplyBulkCBuffer(c,ln-&gt;ele,sdslen(ln-&gt;ele));</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (withscores) &#123;</span><br><span class=\"line\">                addReplyDouble(c,ln-&gt;score);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/* Move to next node */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reverse) &#123;</span><br><span class=\"line\">                ln = ln-&gt;backward;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ln = ln-&gt;level[<span class=\"number\">0</span>].forward;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        serverPanic(<span class=\"string\">\"Unknown sorted set encoding\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//如果有withscores参数,返回给客户端的字符串数量是2倍</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (withscores) &#123;</span><br><span class=\"line\">        rangelen *= <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将rangelen放入replylen指向的位置,返回给客户端</span></span><br><span class=\"line\">    setDeferredMultiBulkLength(c, replylen, rangelen);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ZRANK\"><a href=\"#ZRANK\" class=\"headerlink\" title=\"ZRANK\"></a>ZRANK</h2><p>ZRANK key member</p>\n<p>返回有序集合中元素member的rank</p>\n<p>以0为起始rank,元素分数从低到高</p>\n<p>zrevrank,元素分数从高到低</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">zrankGenericCommand</span><span class=\"params\">(client *c, <span class=\"keyword\">int</span> reverse)</span> </span>&#123;</span><br><span class=\"line\">    robj *key = c-&gt;argv[<span class=\"number\">1</span>];</span><br><span class=\"line\">    robj *ele = c-&gt;argv[<span class=\"number\">2</span>];</span><br><span class=\"line\">    robj *zobj;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> rank;</span><br><span class=\"line\">    <span class=\"comment\">//通过key找出有序集合的value zobj</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((zobj = lookupKeyReadOrReply(c,key,shared.nullbulk)) == <span class=\"literal\">NULL</span> ||</span><br><span class=\"line\">        checkType(c,zobj,OBJ_ZSET)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    serverAssertWithInfo(c,ele,sdsEncodedObject(ele));</span><br><span class=\"line\">    <span class=\"comment\">//在zobj中查找ele(第二个参数member)</span></span><br><span class=\"line\">    rank = zsetRank(zobj,ele-&gt;ptr,reverse);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rank &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        addReplyLongLong(c,rank);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        addReply(c,shared.nullbulk);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">zrankCommand</span><span class=\"params\">(client *c)</span> </span>&#123;</span><br><span class=\"line\">    zrankGenericCommand(c, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">zsetRank</span><span class=\"params\">(robj *zobj, sds ele, <span class=\"keyword\">int</span> reverse)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> llen;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> rank;</span><br><span class=\"line\"></span><br><span class=\"line\">    llen = zsetLength(zobj);</span><br><span class=\"line\">    <span class=\"comment\">//ziplist从前往后遍历,比较entry中的元素与ele,每次将rank++</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *zl = zobj-&gt;ptr;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *eptr, *sptr;</span><br><span class=\"line\"></span><br><span class=\"line\">        eptr = ziplistIndex(zl,<span class=\"number\">0</span>);</span><br><span class=\"line\">        serverAssert(eptr != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        sptr = ziplistNext(zl,eptr);</span><br><span class=\"line\">        serverAssert(sptr != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        rank = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(eptr != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ziplistCompare(eptr,(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>*)ele,sdslen(ele)))</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            rank++;</span><br><span class=\"line\">            zzlNext(zl,&amp;eptr,&amp;sptr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (eptr != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果是逆序取,直接将llen-rank就是逆向的rank</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reverse)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> llen-rank;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> rank<span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"comment\">//skiplist通过zslGetRank获取rank,具体过程为跳表查找,将相应路过节点的span相加</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class=\"line\">        zset *zs = zobj-&gt;ptr;</span><br><span class=\"line\">        zskiplist *zsl = zs-&gt;zsl;</span><br><span class=\"line\">        dictEntry *de;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> score;</span><br><span class=\"line\"></span><br><span class=\"line\">        de = dictFind(zs-&gt;dict,ele);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (de != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            score = *(<span class=\"keyword\">double</span>*)dictGetVal(de);</span><br><span class=\"line\">            rank = zslGetRank(zsl,score,ele);</span><br><span class=\"line\">            <span class=\"comment\">/* Existing elements always have a rank. */</span></span><br><span class=\"line\">            serverAssert(rank != <span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"comment\">//逆向取rank</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reverse)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> llen-rank;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> rank<span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        serverPanic(<span class=\"string\">\"Unknown sorted set encoding\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ZREM\"><a href=\"#ZREM\" class=\"headerlink\" title=\"ZREM\"></a>ZREM</h2><p>ZREM key member [member …]</p>\n<p>从有序集合中删除相应的member</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">zremCommand</span><span class=\"params\">(client *c)</span> </span>&#123;</span><br><span class=\"line\">    robj *key = c-&gt;argv[<span class=\"number\">1</span>];</span><br><span class=\"line\">    robj *zobj;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> deleted = <span class=\"number\">0</span>, keyremoved = <span class=\"number\">0</span>, j;</span><br><span class=\"line\">    <span class=\"comment\">//根据key找到对应的zobj</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == <span class=\"literal\">NULL</span> ||</span><br><span class=\"line\">        checkType(c,zobj,OBJ_ZSET)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">//依次删除相应的元素,每次删除之后检查zset是否为空,如果为空,删掉该key,并且break</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (zsetDel(zobj,c-&gt;argv[j]-&gt;ptr)) deleted++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (zsetLength(zobj) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            dbDelete(c-&gt;db,key);</span><br><span class=\"line\">            keyremoved = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//如果确实有member被删除掉,通知keyspace zrem事件</span></span><br><span class=\"line\">    <span class=\"comment\">//如果zset整个都被删除了,通知keyspace del事件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (deleted) &#123;</span><br><span class=\"line\">        notifyKeyspaceEvent(NOTIFY_ZSET,<span class=\"string\">\"zrem\"</span>,key,c-&gt;db-&gt;id);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (keyremoved)</span><br><span class=\"line\">            notifyKeyspaceEvent(NOTIFY_GENERIC,<span class=\"string\">\"del\"</span>,key,c-&gt;db-&gt;id);</span><br><span class=\"line\">        signalModifiedKey(c-&gt;db,key);</span><br><span class=\"line\">        server.dirty += deleted;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//返回给客户端实际删除的member个数</span></span><br><span class=\"line\">    addReplyLongLong(c,deleted);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Delete the element 'ele' from the sorted set, returning 1 if the element</span></span><br><span class=\"line\"><span class=\"comment\"> * existed and was deleted, 0 otherwise (the element was not there). */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">zsetDel</span><span class=\"params\">(robj *zobj, sds ele)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *eptr;</span><br><span class=\"line\">        <span class=\"comment\">//ziplist先找到ele所在位置的指针eptr</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((eptr = zzlFind(zobj-&gt;ptr,ele,<span class=\"literal\">NULL</span>)) != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//将该元素删除.ziplist删除时会resize,此处将删除之后ziplist的指针复值给zobj-&gt;ptr</span></span><br><span class=\"line\">            zobj-&gt;ptr = zzlDelete(zobj-&gt;ptr,eptr);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class=\"line\">        zset *zs = zobj-&gt;ptr;</span><br><span class=\"line\">        dictEntry *de;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> score;</span><br><span class=\"line\">        <span class=\"comment\">//skiplist现将zobj-&gt;ptr-&gt;dict相应的ele删除掉。此处并未真实删除</span></span><br><span class=\"line\">        <span class=\"comment\">//而是将ele所在的dictEntry返回</span></span><br><span class=\"line\">        de = dictUnlink(zs-&gt;dict,ele);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (de != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* Get the score in order to delete from the skiplist later. */</span></span><br><span class=\"line\">            <span class=\"comment\">//通过dictEntry获取score</span></span><br><span class=\"line\">            score = *(<span class=\"keyword\">double</span>*)dictGetVal(de);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/* Delete from the hash table and later from the skiplist.</span></span><br><span class=\"line\"><span class=\"comment\">             * Note that the order is important: deleting from the skiplist</span></span><br><span class=\"line\"><span class=\"comment\">             * actually releases the SDS string representing the element,</span></span><br><span class=\"line\"><span class=\"comment\">             * which is shared between the skiplist and the hash table, so</span></span><br><span class=\"line\"><span class=\"comment\">             * we need to delete from the skiplist as the final step. */</span></span><br><span class=\"line\">            <span class=\"comment\">//此处将dict中的key和value实际free掉</span></span><br><span class=\"line\">            dictFreeUnlinkedEntry(zs-&gt;dict,de);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/* Delete from skiplist. */</span></span><br><span class=\"line\">            <span class=\"comment\">//从skiplist中删除元素.ele这个sds在hash和skiplist共享.从skiplist中删除时</span></span><br><span class=\"line\">            <span class=\"comment\">//会释放此sds,所以必须先删除dict中的元素再删除skiplist中的元素</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> retval = zslDelete(zs-&gt;zsl,score,ele,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">            serverAssert(retval);</span><br><span class=\"line\">            <span class=\"comment\">//如果hash表中元素使用率小于10%,进行dict的resize</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (htNeedsResize(zs-&gt;dict)) dictResize(zs-&gt;dict);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        serverPanic(<span class=\"string\">\"Unknown sorted set encoding\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">/* No such element found. */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ZADD\"><a href=\"#ZADD\" class=\"headerlink\" title=\"ZADD\"></a>ZADD</h2><p>ZADD key [NX|XX] [CH] [INCR]score member [score member …]</p>\n<p>将元素及对应分值添加到一个有序集合中</p>\n<p>NX:不更新已经存在的key,只增加新元素</p>\n<p>XX:只更新已经存在的key,不增加新元素</p>\n<p>CH:abbr:changed.不指定时只返回新增的元素个数,指定时返回新增的和更新的元素个数之和</p>\n<p>INCR:参考zincrby</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过第二个参数区分是zadd还是zincrby</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">zaddCommand</span><span class=\"params\">(client *c)</span> </span>&#123;</span><br><span class=\"line\">    zaddGenericCommand(c,ZADD_NONE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* This generic command implements both ZADD and ZINCRBY. */</span></span><br><span class=\"line\"><span class=\"comment\">//zadd和zincrby两个命令都是调用这个函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">zaddGenericCommand</span><span class=\"params\">(client *c, <span class=\"keyword\">int</span> flags)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">char</span> *nanerr = <span class=\"string\">\"resulting score is not a number (NaN)\"</span>;</span><br><span class=\"line\">    robj *key = c-&gt;argv[<span class=\"number\">1</span>];</span><br><span class=\"line\">    robj *zobj;</span><br><span class=\"line\">    sds ele;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> score = <span class=\"number\">0</span>, *scores = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j, elements;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> scoreidx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* The following vars are used in order to track what the command actually</span></span><br><span class=\"line\"><span class=\"comment\">     * did during the execution, to reply to the client and to trigger the</span></span><br><span class=\"line\"><span class=\"comment\">     * notification of keyspace change. */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> added = <span class=\"number\">0</span>;      <span class=\"comment\">/* Number of new elements added. */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> updated = <span class=\"number\">0</span>;    <span class=\"comment\">/* Number of elements with updated score. */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> processed = <span class=\"number\">0</span>;  <span class=\"comment\">/* Number of elements processed, may remain zero with</span></span><br><span class=\"line\"><span class=\"comment\">                           options like XX. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Parse options. At the end 'scoreidx' is set to the argument position</span></span><br><span class=\"line\"><span class=\"comment\">     * of the score of the first score-element pair. */</span></span><br><span class=\"line\">    scoreidx = <span class=\"number\">2</span>;<span class=\"comment\">//从第二个参数开始处理.先处理nx,xx,ch,incr参数</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(scoreidx &lt; c-&gt;argc) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> *opt = c-&gt;argv[scoreidx]-&gt;ptr;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!strcasecmp(opt,<span class=\"string\">\"nx\"</span>)) flags |= ZADD_NX;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!strcasecmp(opt,<span class=\"string\">\"xx\"</span>)) flags |= ZADD_XX;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!strcasecmp(opt,<span class=\"string\">\"ch\"</span>)) flags |= ZADD_CH;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!strcasecmp(opt,<span class=\"string\">\"incr\"</span>)) flags |= ZADD_INCR;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        scoreidx++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Turn options into simple to check vars. */</span></span><br><span class=\"line\">    <span class=\"comment\">//从flag中取出相应的标志赋给独立的变量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> incr = (flags &amp; ZADD_INCR) != <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nx = (flags &amp; ZADD_NX) != <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> xx = (flags &amp; ZADD_XX) != <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ch = (flags &amp; ZADD_CH) != <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* After the options, we expect to have an even number of args, since</span></span><br><span class=\"line\"><span class=\"comment\">     * we expect any number of score-element pairs. */</span></span><br><span class=\"line\">    <span class=\"comment\">//member和score是一一对应的,所以肯定是2的倍数.所以如果不是2的倍数或者根本</span></span><br><span class=\"line\">    <span class=\"comment\">//没有member和score,直接返回命令语法错误</span></span><br><span class=\"line\">    elements = c-&gt;argc-scoreidx;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elements % <span class=\"number\">2</span> || !elements) &#123;</span><br><span class=\"line\">        addReply(c,shared.syntaxerr);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//elements赋值为有多少对&lt;element,score&gt;</span></span><br><span class=\"line\">    elements /= <span class=\"number\">2</span>; <span class=\"comment\">/* Now this holds the number of score-element pairs. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Check for incompatible options. */</span></span><br><span class=\"line\">    <span class=\"comment\">//nx和xxflag互斥,二者不能同时出现</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nx &amp;&amp; xx) &#123;</span><br><span class=\"line\">        addReplyError(c,</span><br><span class=\"line\">            <span class=\"string\">\"XX and NX options at the same time are not compatible\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//若有incr标志,则只能有一对&lt;element,score&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">//为什么不能是多对?</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (incr &amp;&amp; elements &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        addReplyError(c,</span><br><span class=\"line\">            <span class=\"string\">\"INCR option supports a single increment-element pair\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Start parsing all the scores, we need to emit any syntax error</span></span><br><span class=\"line\"><span class=\"comment\">     * before executing additions to the sorted set, as the command should</span></span><br><span class=\"line\"><span class=\"comment\">     * either execute fully or nothing at all. */</span></span><br><span class=\"line\">    <span class=\"comment\">//依次检查每一个分数值</span></span><br><span class=\"line\">    scores = zmalloc(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">double</span>)*elements);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; elements; j++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//该函数中会检查score是否是合法的double类型的值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (getDoubleFromObjectOrReply(c,c-&gt;argv[scoreidx+j*<span class=\"number\">2</span>],&amp;scores[j],<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            != C_OK) <span class=\"keyword\">goto</span> cleanup;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Lookup the key and create the sorted set if does not exist. */</span></span><br><span class=\"line\">    <span class=\"comment\">//根据key查找对应的有序集合的value</span></span><br><span class=\"line\">    zobj = lookupKeyWrite(c-&gt;db,key);</span><br><span class=\"line\">    <span class=\"comment\">//key不存在</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zobj == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果设置了xx这个flag,直接返回错误</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (xx) <span class=\"keyword\">goto</span> reply_to_client; <span class=\"comment\">/* No key + XX option: nothing to do. */</span></span><br><span class=\"line\">        <span class=\"comment\">//根据redis的配置,如果有序集合设置了不使用ziplist存储或者说第一个插入元素的长度大于</span></span><br><span class=\"line\">        <span class=\"comment\">//设置的最大ziplist的元素长度值,则使用跳跃表存储否则使用ziplist</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (server.zset_max_ziplist_entries == <span class=\"number\">0</span> ||</span><br><span class=\"line\">            server.zset_max_ziplist_value &lt; sdslen(c-&gt;argv[scoreidx+<span class=\"number\">1</span>]-&gt;ptr))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            zobj = createZsetObject();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            zobj = createZsetZiplistObject();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//把key,zobj插入字典</span></span><br><span class=\"line\">        dbAdd(c-&gt;db,key,zobj);</span><br><span class=\"line\">    <span class=\"comment\">//key存在</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果不是有序集合,直接返回错误</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (zobj-&gt;type != OBJ_ZSET) &#123;</span><br><span class=\"line\">            addReply(c,shared.wrongtypeerr);</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> cleanup;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//elements是&lt;member,score&gt;对数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; elements; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> newscore;</span><br><span class=\"line\">        score = scores[j];</span><br><span class=\"line\">        <span class=\"comment\">//retflags设置为前文中的flags变量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> retflags = flags;</span><br><span class=\"line\"></span><br><span class=\"line\">        ele = c-&gt;argv[scoreidx+<span class=\"number\">1</span>+j*<span class=\"number\">2</span>]-&gt;ptr;</span><br><span class=\"line\">        <span class=\"comment\">//每次遍历,score是分数,ele是member.调用zsetadd插入zobj</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> retval = zsetAdd(zobj, score, ele, &amp;retflags, &amp;newscore);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (retval == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            addReplyError(c,nanerr);</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> cleanup;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//根据retflags,即一个元素是更新还是新加入,还是未做处理(即member存在,并且</span></span><br><span class=\"line\">        <span class=\"comment\">//score值与新设置的一致),更新相应的计数变量(这些变量最后会返回给客户端)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (retflags &amp; ZADD_ADDED) added++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (retflags &amp; ZADD_UPDATED) updated++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(retflags &amp; ZADD_NOP)) processed++;</span><br><span class=\"line\">        score = newscore;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    server.dirty += (added+updated);</span><br><span class=\"line\"><span class=\"comment\">//通过命令中的flag,返回给客户端不同的值</span></span><br><span class=\"line\">reply_to_client:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (incr) &#123; <span class=\"comment\">/* ZINCRBY or INCR option. */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (processed)</span><br><span class=\"line\">            addReplyDouble(c,score);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            addReply(c,shared.nullbulk);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">/* ZADD. */</span></span><br><span class=\"line\">        addReplyLongLong(c,ch ? added+updated : added);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果有更新或者新加,需要执行相应的watch key的通知及keyspace的通知</span></span><br><span class=\"line\">cleanup:</span><br><span class=\"line\">    zfree(scores);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (added || updated) &#123;</span><br><span class=\"line\">        signalModifiedKey(c-&gt;db,key);</span><br><span class=\"line\">        notifyKeyspaceEvent(NOTIFY_ZSET,</span><br><span class=\"line\">            incr ? <span class=\"string\">\"zincr\"</span> : <span class=\"string\">\"zadd\"</span>, key, c-&gt;db-&gt;id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ZINCRBY\"><a href=\"#ZINCRBY\" class=\"headerlink\" title=\"ZINCRBY\"></a>ZINCRBY</h2><p>ZINCRBY key increment member</p>\n<p>如果key存在,就给相应member的score增加increment</p>\n<p>否则直接给key设置分数为increment</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//与zadd调用同一个函数,相当于zadd key incr,把incr flag置位</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">zincrbyCommand</span><span class=\"params\">(client *c)</span> </span>&#123;</span><br><span class=\"line\">    zaddGenericCommand(c,ZADD_INCR);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ZCARD\"><a href=\"#ZCARD\" class=\"headerlink\" title=\"ZCARD\"></a>ZCARD</h2><p>ZCARD key</p>\n<p>返回有序集合的元素个数<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">zcardCommand</span><span class=\"params\">(client *c)</span> </span>&#123;</span><br><span class=\"line\">    robj *key = c-&gt;argv[<span class=\"number\">1</span>];</span><br><span class=\"line\">    robj *zobj;</span><br><span class=\"line\">    <span class=\"comment\">//查找key对应的value</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((zobj = lookupKeyReadOrReply(c,key,shared.czero)) == <span class=\"literal\">NULL</span> ||</span><br><span class=\"line\">        checkType(c,zobj,OBJ_ZSET)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">//通过zsetLength获取zobj中的元素个数</span></span><br><span class=\"line\">    addReplyLongLong(c,zsetLength(zobj));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> <span class=\"title\">zsetLength</span><span class=\"params\">(<span class=\"keyword\">const</span> robj *zobj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//如果是ziplist,通过zzlLength函数获取长度</span></span><br><span class=\"line\">    <span class=\"comment\">//如果长度字段中的值小于UINT16_MAX，直接返回长度。否则需要遍历获取长度</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class=\"line\">        length = zzlLength(zobj-&gt;ptr);</span><br><span class=\"line\">    <span class=\"comment\">//如果是skiplist,直接返回zsl-&gt;length</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class=\"line\">        length = ((<span class=\"keyword\">const</span> zset*)zobj-&gt;ptr)-&gt;zsl-&gt;length;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        serverPanic(<span class=\"string\">\"Unknown sorted set encoding\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> length;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ZCOUNT\"><a href=\"#ZCOUNT\" class=\"headerlink\" title=\"ZCOUNT\"></a>ZCOUNT</h2><p>ZCOUNT key min max</p>\n<p>返回key中score值在min和max之间的元素个数</p>\n<p>其中min和max可以加(,如 zcount key (5 (10 </p>\n<p>加左括号表示不包含。不加表示包含</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">zcountCommand</span><span class=\"params\">(client *c)</span> </span>&#123;</span><br><span class=\"line\">    robj *key = c-&gt;argv[<span class=\"number\">1</span>];</span><br><span class=\"line\">    robj *zobj;</span><br><span class=\"line\">    zrangespec range;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Parse the range arguments */</span></span><br><span class=\"line\">    <span class=\"comment\">//判定范围.并将最大最小及是否包含写入range结构体中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zslParseRange(c-&gt;argv[<span class=\"number\">2</span>],c-&gt;argv[<span class=\"number\">3</span>],&amp;range) != C_OK) &#123;</span><br><span class=\"line\">        addReplyError(c,<span class=\"string\">\"min or max is not a float\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Lookup the sorted set */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == <span class=\"literal\">NULL</span> ||</span><br><span class=\"line\">        checkType(c, zobj, OBJ_ZSET)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">//判断zobj底层编码是ziplist还是skiplist</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *zl = zobj-&gt;ptr;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *eptr, *sptr;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> score;</span><br><span class=\"line\">        <span class=\"comment\">//找出第一个在范围之内的元素</span></span><br><span class=\"line\">        <span class=\"comment\">/* Use the first element in range as the starting point */</span></span><br><span class=\"line\">        eptr = zzlFirstInRange(zl,&amp;range);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* No \"first\" element */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (eptr == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            addReply(c, shared.czero);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* First element is in range */</span></span><br><span class=\"line\">        <span class=\"comment\">//ziplist中member和score是两个entry,并且member之后保存着score</span></span><br><span class=\"line\">        <span class=\"comment\">//整体顺序是按score从小到大排列,score相同时,按member的字典序排列</span></span><br><span class=\"line\">        sptr = ziplistNext(zl,eptr);</span><br><span class=\"line\">        <span class=\"comment\">//所以此处从第一个元素的下一个entry处获取score</span></span><br><span class=\"line\">        score = zzlGetScore(sptr);</span><br><span class=\"line\">        serverAssertWithInfo(c,zobj,zslValueLteMax(score,&amp;range));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Iterate over elements in range */</span></span><br><span class=\"line\">        <span class=\"comment\">//迭代这个ziplist,如果score满足要求,则count++并且继续迭代,否则跳出</span></span><br><span class=\"line\">        <span class=\"comment\">//最后会返回count</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (eptr) &#123;</span><br><span class=\"line\">            score = zzlGetScore(sptr);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/* Abort when the node is no longer in range. */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!zslValueLteMax(score,&amp;range)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">                zzlNext(zl,&amp;eptr,&amp;sptr);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class=\"line\">        zset *zs = zobj-&gt;ptr;</span><br><span class=\"line\">        zskiplist *zsl = zs-&gt;zsl;</span><br><span class=\"line\">        zskiplistNode *zn;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> rank;</span><br><span class=\"line\">        <span class=\"comment\">//如果是跳表,也是先取出第一个元素</span></span><br><span class=\"line\">        <span class=\"comment\">/* Find first element in range */</span></span><br><span class=\"line\">        zn = zslFirstInRange(zsl, &amp;range);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Use rank of first element, if any, to determine preliminary count */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (zn != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取第一个元素的排名</span></span><br><span class=\"line\">            rank = zslGetRank(zsl, zn-&gt;score, zn-&gt;ele);</span><br><span class=\"line\">            count = (zsl-&gt;length - (rank - <span class=\"number\">1</span>));</span><br><span class=\"line\">            <span class=\"comment\">//如果最大值大于zsl中的最大值,则此count就是要找的个数</span></span><br><span class=\"line\">            <span class=\"comment\">/* Find last element in range */</span></span><br><span class=\"line\">            zn = zslLastInRange(zsl, &amp;range);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/* Use rank of last element, if any, to determine the actual count */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (zn != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果最大值小于zsl中的最大值，则首先找到最后一个元素的rank</span></span><br><span class=\"line\">                rank = zslGetRank(zsl, zn-&gt;score, zn-&gt;ele);</span><br><span class=\"line\">                <span class=\"comment\">//重新计算count,与之前的计算公式合并之后为</span></span><br><span class=\"line\">                <span class=\"comment\">//count = (zsl-&gt;length-(rankmin-1))-(zsl-&gt;length-rankmax))</span></span><br><span class=\"line\">                <span class=\"comment\">//      = rankmax-rankmin+1</span></span><br><span class=\"line\">                count -= (zsl-&gt;length - rank);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        serverPanic(<span class=\"string\">\"Unknown sorted set encoding\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//返回count</span></span><br><span class=\"line\">    addReplyLongLong(c, count);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ZRANGEBYSCORE\"><a href=\"#ZRANGEBYSCORE\" class=\"headerlink\" title=\"ZRANGEBYSCORE\"></a>ZRANGEBYSCORE</h2><p>ZRANGEBYSCORE key min max [WITHSCORES][LIMIT offset count]</p>\n<p>获取有序结合中分值位于 min和max之间的所有元素</p>\n<p>withscores:将member 和 score一起返回 </p>\n<p>limit offset count:从偏移offset开始获取count个元素</p>\n<p>min和max可以为 -inf,+inf,分别表示负无穷和正无穷</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//入口函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">zrangebyscoreCommand</span><span class=\"params\">(client *c)</span> </span>&#123;</span><br><span class=\"line\">    genericZrangebyscoreCommand(c,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* This command implements ZRANGEBYSCORE, ZREVRANGEBYSCORE. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">genericZrangebyscoreCommand</span><span class=\"params\">(client *c, <span class=\"keyword\">int</span> reverse)</span> </span>&#123;</span><br><span class=\"line\">    zrangespec range;</span><br><span class=\"line\">    robj *key = c-&gt;argv[<span class=\"number\">1</span>];</span><br><span class=\"line\">    robj *zobj;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> offset = <span class=\"number\">0</span>, limit = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> withscores = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> rangelen = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *replylen = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> minidx, maxidx;</span><br><span class=\"line\">    <span class=\"comment\">//该函数同时用于zrangbyscore和zrevrangebyscore</span></span><br><span class=\"line\">    <span class=\"comment\">//二者通过函数中的reverse参数标识</span></span><br><span class=\"line\">    <span class=\"comment\">//正序时第二个参数是min，第三个参数是max,逆序反之</span></span><br><span class=\"line\">    <span class=\"comment\">/* Parse the range arguments. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (reverse) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* Range is given as [max,min] */</span></span><br><span class=\"line\">        maxidx = <span class=\"number\">2</span>; minidx = <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* Range is given as [min,max] */</span></span><br><span class=\"line\">        minidx = <span class=\"number\">2</span>; maxidx = <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将参数解析出来赋值到range变量</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zslParseRange(c-&gt;argv[minidx],c-&gt;argv[maxidx],&amp;range) != C_OK) &#123;</span><br><span class=\"line\">        addReplyError(c,<span class=\"string\">\"min or max is not a float\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Parse optional extra arguments. Note that ZCOUNT will exactly have</span></span><br><span class=\"line\"><span class=\"comment\">     * 4 arguments, so we'll never enter the following code path. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c-&gt;argc &gt; <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> remaining = c-&gt;argc - <span class=\"number\">4</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pos = <span class=\"number\">4</span>;</span><br><span class=\"line\">        <span class=\"comment\">//解析withscores和limit参数</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (remaining) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (remaining &gt;= <span class=\"number\">1</span> &amp;&amp; !strcasecmp(c-&gt;argv[pos]-&gt;ptr,<span class=\"string\">\"withscores\"</span>)) &#123;</span><br><span class=\"line\">                pos++; remaining--;</span><br><span class=\"line\">                withscores = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (remaining &gt;= <span class=\"number\">3</span> &amp;&amp; !strcasecmp(c-&gt;argv[pos]-&gt;ptr,<span class=\"string\">\"limit\"</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[pos+<span class=\"number\">1</span>], &amp;offset, <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                        != C_OK) ||</span><br><span class=\"line\">                    (getLongFromObjectOrReply(c, c-&gt;argv[pos+<span class=\"number\">2</span>], &amp;limit, <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                        != C_OK))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                pos += <span class=\"number\">3</span>; remaining -= <span class=\"number\">3</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                addReply(c,shared.syntaxerr);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Ok, lookup the key and get the range */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == <span class=\"literal\">NULL</span> ||</span><br><span class=\"line\">        checkType(c,zobj,OBJ_ZSET)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">//按zset底层编码是ziplist还是skiplist分别处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *zl = zobj-&gt;ptr;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *eptr, *sptr;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *vstr;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> vlen;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> vlong;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> score;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* If reversed, get the last node in range as starting point. */</span></span><br><span class=\"line\">        <span class=\"comment\">//按正序还是逆序分别取最后一个值或者第一个值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (reverse) &#123;</span><br><span class=\"line\">            eptr = zzlLastInRange(zl,&amp;range);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            eptr = zzlFirstInRange(zl,&amp;range);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* No \"first\" element in the specified interval. */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (eptr == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            addReply(c, shared.emptymultibulk);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Get score pointer for the first element. */</span></span><br><span class=\"line\">        serverAssertWithInfo(c,zobj,eptr != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        sptr = ziplistNext(zl,eptr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* We don't know in advance how many matching elements there are in the</span></span><br><span class=\"line\"><span class=\"comment\">         * list, so we push this object that will represent the multi-bulk</span></span><br><span class=\"line\"><span class=\"comment\">         * length in the output buffer, and will \"fix\" it later */</span></span><br><span class=\"line\">        replylen = addDeferredMultiBulkLength(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* If there is an offset, just traverse the number of elements without</span></span><br><span class=\"line\"><span class=\"comment\">         * checking the score because that is done in the next loop. */</span></span><br><span class=\"line\">        <span class=\"comment\">//如果有offset,先偏移相应的元素</span></span><br><span class=\"line\">        <span class=\"comment\">//注意此处zzlNext传入了两个指针,会一次偏移一个&lt;member,score&gt;对</span></span><br><span class=\"line\">        <span class=\"comment\">//注意此处offset初始值是0,如果没指定则不会进入此处循环</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (eptr &amp;&amp; offset--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reverse) &#123;</span><br><span class=\"line\">                zzlPrev(zl,&amp;eptr,&amp;sptr);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                zzlNext(zl,&amp;eptr,&amp;sptr);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果有limit,则进入循环.取limit次.limit的初始值为-1,即使没指定,也会进入循环</span></span><br><span class=\"line\">        <span class=\"comment\">//直到eptr为null或者循环中break掉</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (eptr &amp;&amp; limit--) &#123;</span><br><span class=\"line\">            score = zzlGetScore(sptr);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/* Abort when the node is no longer in range. */</span></span><br><span class=\"line\">            <span class=\"comment\">//不在范围之内时break掉</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reverse) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!zslValueGteMin(score,&amp;range)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!zslValueLteMax(score,&amp;range)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/* We know the element exists, so ziplistGet should always succeed */</span></span><br><span class=\"line\">            serverAssertWithInfo(c,zobj,ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vlong));</span><br><span class=\"line\">            <span class=\"comment\">//取出相应的值.可能为str,赋值给vstr,长度为vlen,或者为整型,赋值给vlong</span></span><br><span class=\"line\">            rangelen++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (vstr == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">                addReplyBulkLongLong(c,vlong);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                addReplyBulkCBuffer(c,vstr,vlen);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//如果设置了withscores标志,则返回分数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (withscores) &#123;</span><br><span class=\"line\">                addReplyDouble(c,score);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//开始迭代下一个节点</span></span><br><span class=\"line\">            <span class=\"comment\">/* Move to next node */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reverse) &#123;</span><br><span class=\"line\">                zzlPrev(zl,&amp;eptr,&amp;sptr);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                zzlNext(zl,&amp;eptr,&amp;sptr);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class=\"line\">        zset *zs = zobj-&gt;ptr;</span><br><span class=\"line\">        zskiplist *zsl = zs-&gt;zsl;</span><br><span class=\"line\">        zskiplistNode *ln;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//同ziplist,先查找起始或最终节点</span></span><br><span class=\"line\">        <span class=\"comment\">/* If reversed, get the last node in range as starting point. */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (reverse) &#123;</span><br><span class=\"line\">            ln = zslLastInRange(zsl,&amp;range);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ln = zslFirstInRange(zsl,&amp;range);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* No \"first\" element in the specified interval. */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ln == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            addReply(c, shared.emptymultibulk);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* We don't know in advance how many matching elements there are in the</span></span><br><span class=\"line\"><span class=\"comment\">         * list, so we push this object that will represent the multi-bulk</span></span><br><span class=\"line\"><span class=\"comment\">         * length in the output buffer, and will \"fix\" it later */</span></span><br><span class=\"line\">        <span class=\"comment\">//返回客户端时先返回元素个数,但此处并不知道需要返回多少个元素,所以先占个位置</span></span><br><span class=\"line\">        <span class=\"comment\">//replylen是存储len字段的指针</span></span><br><span class=\"line\">        replylen = addDeferredMultiBulkLength(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* If there is an offset, just traverse the number of elements without</span></span><br><span class=\"line\"><span class=\"comment\">         * checking the score because that is done in the next loop. */</span></span><br><span class=\"line\">        <span class=\"comment\">//处理offset.向前或向后skip</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (ln &amp;&amp; offset--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reverse) &#123;</span><br><span class=\"line\">                ln = ln-&gt;backward;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ln = ln-&gt;level[<span class=\"number\">0</span>].forward;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//处理limit</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (ln &amp;&amp; limit--) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* Abort when the node is no longer in range. */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reverse) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!zslValueGteMin(ln-&gt;score,&amp;range)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!zslValueLteMax(ln-&gt;score,&amp;range)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            rangelen++;</span><br><span class=\"line\">            addReplyBulkCBuffer(c,ln-&gt;ele,sdslen(ln-&gt;ele));</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (withscores) &#123;</span><br><span class=\"line\">                addReplyDouble(c,ln-&gt;score);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/* Move to next node */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reverse) &#123;</span><br><span class=\"line\">                ln = ln-&gt;backward;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ln = ln-&gt;level[<span class=\"number\">0</span>].forward;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        serverPanic(<span class=\"string\">\"Unknown sorted set encoding\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//如果有withscores参数,返回给客户端的字符串数量是2倍</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (withscores) &#123;</span><br><span class=\"line\">        rangelen *= <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将rangelen放入replylen指向的位置,返回给客户端</span></span><br><span class=\"line\">    setDeferredMultiBulkLength(c, replylen, rangelen);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ZRANK\"><a href=\"#ZRANK\" class=\"headerlink\" title=\"ZRANK\"></a>ZRANK</h2><p>ZRANK key member</p>\n<p>返回有序集合中元素member的rank</p>\n<p>以0为起始rank,元素分数从低到高</p>\n<p>zrevrank,元素分数从高到低</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">zrankGenericCommand</span><span class=\"params\">(client *c, <span class=\"keyword\">int</span> reverse)</span> </span>&#123;</span><br><span class=\"line\">    robj *key = c-&gt;argv[<span class=\"number\">1</span>];</span><br><span class=\"line\">    robj *ele = c-&gt;argv[<span class=\"number\">2</span>];</span><br><span class=\"line\">    robj *zobj;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> rank;</span><br><span class=\"line\">    <span class=\"comment\">//通过key找出有序集合的value zobj</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((zobj = lookupKeyReadOrReply(c,key,shared.nullbulk)) == <span class=\"literal\">NULL</span> ||</span><br><span class=\"line\">        checkType(c,zobj,OBJ_ZSET)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    serverAssertWithInfo(c,ele,sdsEncodedObject(ele));</span><br><span class=\"line\">    <span class=\"comment\">//在zobj中查找ele(第二个参数member)</span></span><br><span class=\"line\">    rank = zsetRank(zobj,ele-&gt;ptr,reverse);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rank &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        addReplyLongLong(c,rank);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        addReply(c,shared.nullbulk);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">zrankCommand</span><span class=\"params\">(client *c)</span> </span>&#123;</span><br><span class=\"line\">    zrankGenericCommand(c, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">zsetRank</span><span class=\"params\">(robj *zobj, sds ele, <span class=\"keyword\">int</span> reverse)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> llen;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> rank;</span><br><span class=\"line\"></span><br><span class=\"line\">    llen = zsetLength(zobj);</span><br><span class=\"line\">    <span class=\"comment\">//ziplist从前往后遍历,比较entry中的元素与ele,每次将rank++</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *zl = zobj-&gt;ptr;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *eptr, *sptr;</span><br><span class=\"line\"></span><br><span class=\"line\">        eptr = ziplistIndex(zl,<span class=\"number\">0</span>);</span><br><span class=\"line\">        serverAssert(eptr != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        sptr = ziplistNext(zl,eptr);</span><br><span class=\"line\">        serverAssert(sptr != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        rank = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(eptr != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ziplistCompare(eptr,(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span>*)ele,sdslen(ele)))</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            rank++;</span><br><span class=\"line\">            zzlNext(zl,&amp;eptr,&amp;sptr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (eptr != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果是逆序取,直接将llen-rank就是逆向的rank</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reverse)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> llen-rank;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> rank<span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"comment\">//skiplist通过zslGetRank获取rank,具体过程为跳表查找,将相应路过节点的span相加</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class=\"line\">        zset *zs = zobj-&gt;ptr;</span><br><span class=\"line\">        zskiplist *zsl = zs-&gt;zsl;</span><br><span class=\"line\">        dictEntry *de;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> score;</span><br><span class=\"line\"></span><br><span class=\"line\">        de = dictFind(zs-&gt;dict,ele);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (de != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            score = *(<span class=\"keyword\">double</span>*)dictGetVal(de);</span><br><span class=\"line\">            rank = zslGetRank(zsl,score,ele);</span><br><span class=\"line\">            <span class=\"comment\">/* Existing elements always have a rank. */</span></span><br><span class=\"line\">            serverAssert(rank != <span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"comment\">//逆向取rank</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reverse)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> llen-rank;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> rank<span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        serverPanic(<span class=\"string\">\"Unknown sorted set encoding\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ZREM\"><a href=\"#ZREM\" class=\"headerlink\" title=\"ZREM\"></a>ZREM</h2><p>ZREM key member [member …]</p>\n<p>从有序集合中删除相应的member</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">zremCommand</span><span class=\"params\">(client *c)</span> </span>&#123;</span><br><span class=\"line\">    robj *key = c-&gt;argv[<span class=\"number\">1</span>];</span><br><span class=\"line\">    robj *zobj;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> deleted = <span class=\"number\">0</span>, keyremoved = <span class=\"number\">0</span>, j;</span><br><span class=\"line\">    <span class=\"comment\">//根据key找到对应的zobj</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == <span class=\"literal\">NULL</span> ||</span><br><span class=\"line\">        checkType(c,zobj,OBJ_ZSET)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">//依次删除相应的元素,每次删除之后检查zset是否为空,如果为空,删掉该key,并且break</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (zsetDel(zobj,c-&gt;argv[j]-&gt;ptr)) deleted++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (zsetLength(zobj) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            dbDelete(c-&gt;db,key);</span><br><span class=\"line\">            keyremoved = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//如果确实有member被删除掉,通知keyspace zrem事件</span></span><br><span class=\"line\">    <span class=\"comment\">//如果zset整个都被删除了,通知keyspace del事件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (deleted) &#123;</span><br><span class=\"line\">        notifyKeyspaceEvent(NOTIFY_ZSET,<span class=\"string\">\"zrem\"</span>,key,c-&gt;db-&gt;id);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (keyremoved)</span><br><span class=\"line\">            notifyKeyspaceEvent(NOTIFY_GENERIC,<span class=\"string\">\"del\"</span>,key,c-&gt;db-&gt;id);</span><br><span class=\"line\">        signalModifiedKey(c-&gt;db,key);</span><br><span class=\"line\">        server.dirty += deleted;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//返回给客户端实际删除的member个数</span></span><br><span class=\"line\">    addReplyLongLong(c,deleted);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Delete the element 'ele' from the sorted set, returning 1 if the element</span></span><br><span class=\"line\"><span class=\"comment\"> * existed and was deleted, 0 otherwise (the element was not there). */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">zsetDel</span><span class=\"params\">(robj *zobj, sds ele)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *eptr;</span><br><span class=\"line\">        <span class=\"comment\">//ziplist先找到ele所在位置的指针eptr</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((eptr = zzlFind(zobj-&gt;ptr,ele,<span class=\"literal\">NULL</span>)) != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//将该元素删除.ziplist删除时会resize,此处将删除之后ziplist的指针复值给zobj-&gt;ptr</span></span><br><span class=\"line\">            zobj-&gt;ptr = zzlDelete(zobj-&gt;ptr,eptr);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class=\"line\">        zset *zs = zobj-&gt;ptr;</span><br><span class=\"line\">        dictEntry *de;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> score;</span><br><span class=\"line\">        <span class=\"comment\">//skiplist现将zobj-&gt;ptr-&gt;dict相应的ele删除掉。此处并未真实删除</span></span><br><span class=\"line\">        <span class=\"comment\">//而是将ele所在的dictEntry返回</span></span><br><span class=\"line\">        de = dictUnlink(zs-&gt;dict,ele);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (de != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* Get the score in order to delete from the skiplist later. */</span></span><br><span class=\"line\">            <span class=\"comment\">//通过dictEntry获取score</span></span><br><span class=\"line\">            score = *(<span class=\"keyword\">double</span>*)dictGetVal(de);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/* Delete from the hash table and later from the skiplist.</span></span><br><span class=\"line\"><span class=\"comment\">             * Note that the order is important: deleting from the skiplist</span></span><br><span class=\"line\"><span class=\"comment\">             * actually releases the SDS string representing the element,</span></span><br><span class=\"line\"><span class=\"comment\">             * which is shared between the skiplist and the hash table, so</span></span><br><span class=\"line\"><span class=\"comment\">             * we need to delete from the skiplist as the final step. */</span></span><br><span class=\"line\">            <span class=\"comment\">//此处将dict中的key和value实际free掉</span></span><br><span class=\"line\">            dictFreeUnlinkedEntry(zs-&gt;dict,de);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/* Delete from skiplist. */</span></span><br><span class=\"line\">            <span class=\"comment\">//从skiplist中删除元素.ele这个sds在hash和skiplist共享.从skiplist中删除时</span></span><br><span class=\"line\">            <span class=\"comment\">//会释放此sds,所以必须先删除dict中的元素再删除skiplist中的元素</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> retval = zslDelete(zs-&gt;zsl,score,ele,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">            serverAssert(retval);</span><br><span class=\"line\">            <span class=\"comment\">//如果hash表中元素使用率小于10%,进行dict的resize</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (htNeedsResize(zs-&gt;dict)) dictResize(zs-&gt;dict);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        serverPanic(<span class=\"string\">\"Unknown sorted set encoding\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">/* No such element found. */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}