---
title: LevelDB新书介绍
date: 2021-11-24 
tags:
 - LevelDB
 - Mysql
 - Redis
---

## 数据库的演变

关于数据库大家都不陌生,互联网公司从业者熟悉的关系型数据库Mysql、Key-Value存储Redis、分布式数据库Hbase,传统行业从业者熟悉的商业型数据库Oracle,DB2.数据库顾名思义是用来存储数据的一个软件,但数据存储也可以直接存储到文件,例如我们平时应用中打日志就是将数据直接输出到文件系统中的一个文件，那为什么需要数据库呢？
继续思考打日志这个事情,首先我们只能以追加的形式写入日志文件,查找日志时需要使用Linux系统中的grep命令抓取关键字,如果日志很大,grep命令执行起来会很慢,假设需要汇总统计,那还需要继续加管道使用wc,sort或者写一个awk脚本.而且实际使用中,数据不只需要插入和查找,还需要更新和删除.许多场景下需要事务功能,保证一组工作的逻辑单元要么一起做,要么回滚到执行前的状态.

LNMP（Linux、Nginx、Mysql、PHP）就是一种分层或者分工,着眼于各自的关注点,Mysql用来保证数据的增删改查与事务的ACID特性,PHP或者其他语言着眼于应用实现.为了保证数据量增大后能够快速查找,数据库需要有索引,为了实现汇总统计功能,数据库需要有实现各种算法实现聚合与统计,为了实现事务的ACID特性,数据库需要使用Redo/Undo Log.

传统数据量不多的单体应用,建模可以完全基于关系型数据库,例如要实现一个订单系统,需要包括如下几个实体:
* 客户表:包括客户ID、名字、性别、电话、地址
* 商品表:包括商品ID、商品信息、商品价格
* 订单表:包括订单ID、订单时间、客户ID、客户名称、客户地址
* 订单详情表:包括订单ID、商品ID、单价、数量、折扣、商品名称
以客户表为例,根据数据库设计第一范式:字段的原子性,地址又要详细拆分为国家以及省市街道,这样如果需要统计某个国家或者某个省的客户数量,可以直接通过省份信息进行聚合汇总.而地址又分家庭地址、工作地址以及其他一些临时地址,因此需要单独将地址拆分为一个表:
* 地址表:地址ID、国家、省、市、街道、小区、楼门号
此时地址表与客户表是一个多对一的关系,因此需要在地址表中增加客户表的客户ID字段进行关联 
这么设计类似于代码中的解耦,假设街道或者小区更名,只需要更新地址表,不需要处理客户表.

以订单详情表为例,根据数据设计第二范式:没有包含在主键中的列必须完全依赖于主键.此时主键为<订单ID、商品ID>,数量、折扣完全依赖于主键,而单价和商品名称其实依赖于商品ID,部分依赖于主键.为什么需要第二范式呢,其实还是为了减少冗余以及后续更新的方便,此时如果更新商品名称,那所有的订单详情都需要同步更新一遍.

数据库第三范式:任何字段不能由其他字段派生出来,即不存在冗余字段.
根据三范式设计出数据库库表结构后,表间结构可以分为三种情况:
* 一对一
* 一对多
* 多对多
一对一只需要将任意一方的主键ID增加到另一方的表内,一对多需要将一方的主键ID增加到多方的表内,例如订单表中客户ID和订单ID就是一对多的关系,因此需要将客户ID增加到订单表内.而多对多需要一张专门的关系表来保存关系,例如客户和商品之间是多对多的关系,那么需要一张<主键ID,客户ID,商品ID>的多对多关系表

通过数据库的建模,应用实现就比较简单了,例如实现客户信息页,需要将客户表和地址表进行联合查询,更改地址表或者更改客户信息也只需要进行相应表的操作.查看客户的订单列表,就需要关联客户表查找客户ID,通过客户ID查找订单表中的订单ID,通过订单ID可以查找订单详情表中的商品ID,通过商品ID可以查找商品详情,当然实际操作中可以通过SQL进行关联查询

通过数据库建模,应用层的实现只需要调用相应的SQL实现增删改查.但随着数据量的急剧增加,使用join开始变得越来越慢,并且单表的承载量有限,面临着分库、分表,此时如果要继续实现join功能面临着更大的成本与挑战.而且随着互联网的兴起,面临的现实问题不同,建模的方法也不同.此时KV存储就登上了历史舞台.

KV存储模型很简单,通过一个key获取其对应的value,没有其他多余的属性,因此也就不适用于关系型数据库建模的三范式.根据KV存储依赖的存储介质,主要分为两大类,基于内存的kv,代表为memcache,redis,基于硬盘的kv,包括leveldb,rocksdb，

那么,kv存储和传统的关系型数据库有什么相似的地方呢？其实很简单,从根本实现来说,都是根据其功能,依赖于一定的数据结构与算法来实现.我们一起通过Mysql、Redis、LevelDB来看下其使用到的数据结构及其相似的地方.
## 数据库不变的地方





